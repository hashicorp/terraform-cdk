---
page_title: Project Setup
description: >-
  Build a CDKTF application from a template or existing HCL project, and
  configure storage for Terraform state.
---

# Project Setup

There are several ways to create a new CDK for Terraform (CDKTF) project. You can create a new application from a pre-built or a custom template, and you can also convert an existing HCL project. When you create a new project, you can store Terraform state locally or use a [remote backend](/cdktf/concepts/remote-backends). This page discusses these setup options in more detail.

> **Hands On**: Try the [CDK for Terraform Quick Start Demo](https://learn.hashicorp.com/tutorials/terraform/cdktf-install?in=terraform/cdktf) and language-specific [Get Started Tutorials](https://learn.hashicorp.com/collections/terraform/cdktf) on HashiCorp Learn.

## Initialize Project from a Template

Use `init` with a project template to automatically create and scaffold a new CDKTF project for your chosen programming language.
Templates generate a new application with the necessary file structure for you to start defining infrastructure.

You can use a `cdktf-cli` pre-built template or a custom-built [remote template](/cdktf/create-and-deploy/remote-templates) when you initialize a new project.

```bash
$ cdktf init --template="templateName"
```

Use these template names for the available pre-built templates:

- `typescript`
- `python`
- `c#`
- `java`
- `go` (experimental)

### Use a Local Backend

Your application needs somewhere to store [Terraform state](/language/state). Add the `--local` flag to created a scaffolded project that is pre-configured to use a [local backend](/language/settings/backends/local). This means all terraform operations will happen on your local machine.

```
$ cdktf init --template="typescript" --local
```

### Use Terraform Cloud as a Remote Backend

You can configure Terraform Cloud as a remote backend if you do not want to store your Terraform state locally. Refer to [Terraform Cloud docs](/cdktf/concepts/terraform-cloud) for setup details.

#### Terraform Cloud VCS Integration

Terraform Cloud supports [connecting to VCS providers](/cloud-docs/vcs). To use the VCS integration:

1. Commit the synthesized Terraform config (the `cdktf.out` directory) alongside your code, so that Terraform Cloud can use it to deploy your infrastructure.
1. On the **General Settings** page of your Terraform Cloud workspace, [set the Terraform working directory](/cloud-docs/workspaces/settings#terraform-working-directory) to the output directory of the stack you want to deploy. For example, use `cdktf.out/stacks/dev` if your stack is named `dev`.

Refer to [Stacks](/cdktf/concepts/stacks) for more information about using stacks to separate the state management for multiple environments in an application.

~> **Important**: The synthesized Terraform config might contain credentials or other sensitive data that was provided as input for the `cdktf` application. Use [Terraform input variables](/cdktf/concepts/variables-and-outputs#input-variables) to pass secrets configured as [workspace-specific variables](cloud-docs/workspaces/variables/managing-variables#workspace-specific-variables) in TerraformCloud.

#### External CI service

If you prefer to keep the generated artifacts out of your repository, use any CI (Continuous Integration) service to build and deploy them instead. The CDK for Terraform CLI supports deploying to Terraform Cloud using either the local or remote execution mode. For more information on how runs work in Terraform Cloud, see [Terraform Runs and Remote Operations](/cloud-docs/run).

Use the [`cdktf-cli` commands](/cdktf/cli-reference/commands) as part of your CI steps to synthesize your code and deploy your infrastructure.

```
cdktf deploy --auto-approve
```

## Project Configuration

Initializing your project with a template generates a basic project in your preferred programming language that you can customize for your use case. You can manage global configuration for your project by customizing the `cdktf.json` configuration file or the application context.

### `cdktf.json` Configuration File

The `cdktf.json` configuration file is where you can define the [providers](/cdktf/concepts/providers-and-resources) and [modules](/cdktf/concepts/modules) that should be added to the project and supply custom configuration settings for the application. Refer to the [cdktf.json documentation](/cdktf/create-and-deploy/configuration-file) for more detail.

### Application Context

All of the classes in your application can access the application `context`, so it is an ideal place to store project configuration. Context becomes available to any construct in your application after you run `cdktf synth`.

You can configure context as a static value in `cdktf.json` by setting the `context` property.

```jsonc
{
  // ...
  "context": {
    "myConfig": "value"
  }
```

You can also provide context when instantiating the `App` class.

<CodeTabs>

```ts
import { App } from "cdktf";
const app = new App({ context: { myConfig: "value" } });
app.synth();
```

```python
from cdktf import App
app = App(context={"my_config": "value"})
app.synth()
```

```java
import com.hashicorp.cdktf.App;
App app = App.Builder.create().context(Map.of("myConfig", "value")).build();
app.synth();
```

```csharp
using HashiCorp.Cdktf;
App app = new App(new AppOptions { Context = new Dictionary<string, object> { { "myConfig", "value" } } });
app.Synth();
```

```go
import "github.com/hashicorp/terraform-cdk-go/cdktf"
app := cdktf.NewApp(&cdktf.AppOptions{
	context: map[string]interface{}{
		"myConfig": jsii.String("value"),
	},
})
app.Synth()
```

</CodeTabs>

The example below uses `App` context to provide a custom tag value to an AWS EC2 instance.

<CodeTabs>

```ts
import { Construct } from "constructs";
import { App, TerraformStack } from "cdktf";
import { AwsProvider, ec2 } from "@cdktf/provider-aws";

class MyStack extends TerraformStack {
  constructor(scope: Construct, id: string) {
    super(scope, id);

    new AwsProvider(this, "aws", {
      region: "us-east-1",
    });

    new ec2.Instance(this, "Hello", {
      ami: "ami-2757f631",
      instanceType: "t2.micro",
      tags: {
        myConfig: this.node.tryGetContext("myConfig"),
      },
    });
  }
}

const app = new App({ context: { myConfig: "value" } });
new MyStack(app, "hello-cdktf");
app.synth();
```

```python
from constructs import Construct
from cdktf import App, TerraformStack
from cdktf_cdktf_provider_aws import AwsProvider, ec2

class MyStack(TerraformStack):
    def __init__(self, scope, id):
        super().__init__(scope, id)

        AwsProvider(self, "aws",
            region="us-east-1"
        )

        ec2.Instance(self, "Hello",
            ami="ami-2757f631",
            instance_type="t2.micro",
            tags={
                "my_config": self.node.try_get_context("myConfig")
            }
        )

app = App(context={"my_config": "value"})
MyStack(app, "hello-cdktf")
app.synth()
```

```java
import software.constructs.Construct;
import com.hashicorp.cdktf.App;
import com.hashicorp.cdktf.TerraformStack;
import com.hashicorp.cdktf.providers.aws.AwsProvider;
import com.hashicorp.cdktf.providers.aws.ec2.*;

public class MyStack extends TerraformStack {
    public MyStack(Construct scope, String id) {
        super(scope, id);

        AwsProvider.Builder.create(this, "aws")
                .region("us-east-1")
                .build();

        Instance.Builder.create(this, "Hello")
                .ami("ami-2757f631")
                .instanceType("t2.micro")
                .tags(Map.of(
                        "myConfig", this.node.tryGetContext("myConfig")))
                .build();
    }
}

App app = App.Builder.create().context(Map.of("myConfig", "value")).build();
new MyStack(app, "hello-cdktf");
app.synth();
```

```csharp
using Constructs;
using HashiCorp.Cdktf;
using HashiCorp.Cdktf.Providers.Aws;
using HashiCorp.Cdktf.Providers.Aws.ec2;

class MyStack : TerraformStack
{
    public MyStack(Construct scope, string id) : base(scope, id)
    {

        new AwsProvider(this, "aws", new AwsProviderConfig {
            Region = "us-east-1"
        });

        new Instance(this, "Hello", new InstanceConfig {
            Ami = "ami-2757f631",
            InstanceType = "t2.micro",
            Tags = new Dictionary<string, string> {
                { "myConfig", Node.TryGetContext("myConfig") }
            }
        });
    }
}

App app = new App(new AppOptions { Context = new Dictionary<string, object> { { "myConfig", "value" } } });
new MyStack(app, "hello-cdktf");
app.Synth();
```

```go
import "github.com/aws/constructs-go/constructs"
import "github.com/hashicorp/terraform-cdk-go/cdktf"
import "github.com/hashicorp/cdktf-provider-aws-go/aws"

type myStack struct {
	terraformStack
}

func NewMyStack(scope construct, id *string) *myStack {
	this := &myStack{}
	NewTerraformStack_Override(this, scope, id)

	aws.NewAwsProvider(this, jsii.String("aws"), &aws.awsProviderConfig{
		region: jsii.String("us-east-1"),
	})

	aws.Ec2.NewInstance(this, jsii.String("Hello"), &aws.Ec2.InstanceConfig{
		ami: jsii.String("ami-2757f631"),
		instanceType: jsii.String("t2.micro"),
		tags: map[string]*string{
			"myConfig": this.node.tryGetContext(jsii.String("myConfig")),
		},
	})
	return this
}

app := cdktf.NewApp(&cdktf.AppOptions{
	context: map[string]interface{}{
		"myConfig": jsii.String("value"),
	},
})
NewMyStack(app, jsii.String("hello-cdktf"))
app.Synth()
```

</CodeTabs>

## Generate Terraform Configuration

Run [`cdktf synth`](/cdktf/cli-reference/commands#synth) to synthesize your application into JSON configuration files that Terraform can use to manage infrastructure. You can then either use the JSON file with Terraform directly or provision your infrastructure using CDKTF CLI commands.

## Convert an HCL Project to a CDKTF TypeScript Project

You can initialize a new CDKTF TypeScript project from an existing project written in HashiCorp Configuration Language (HCL). This option is currently limited to the `typescript` template.

To convert an existing HCL project, add `--from-terraform-project` to the `init` command with the TypeScript template.

```
$ cdktf init --template=typescript --from-terraform-project /path/to/my/tf-hcl-project
```

### Usage Example

Consider the HCL configuration below.

```hcl
# File: /tmp/demo/main.tf

terraform {
  required_providers {
    random = {
      source = "hashicorp/random"
      version = "3.1.0"
    }
  }
}

provider "random" {
}

resource "random_pet" "server" {
}
```

Run the command to convert the HCL project in a new folder.

```sh
cdktf init --template=typescript --from-terraform-project /tmp/demo --local
```

CDKTF bootstraps a Typescript project and generates the equivalent configuration in JSON.

```jsonc
// File: /tmp/cdktf-demo/cdktf.json

{
  "language": "typescript",
  "app": "npm run --silent compile && node main.js",
  "projectId": "83684893-0e58-4a71-989a-ecb7c593a690",
  "terraformProviders": ["hashicorp/random@3.1.0"],
  "terraformModules": [],
  "context": {
    "excludeStackIdFromLogicalIds": "true",
    "allowSepCharsInLogicalIds": "true"
  }
}
```

```ts
// File: /tmp/cdktf-demo/main.ts

/*Provider bindings are generated by running cdktf get.
See https://github.com/hashicorp/terraform-cdk/blob/main/docs/working-with-cdk-for-terraform/using-providers.md#importing-providers-and-modules for more details.*/
import * as random from "./.gen/providers/random";

import { Construct } from "constructs";
import { App, TerraformStack } from "cdktf";

class MyStack extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);

    new random.RandomProvider(this, "random", {});
    new random.Pet(this, "server", {});
  }
}

const app = new App();
new MyStack(app, "cdktf-demo");
app.synth();
```

## Convert HCL Files to CDKTF Format

Use the `cdktf convert` command to convert individual HCL files to CDKTF-compatible files in your preferred programming language. Refer to the [`cdktf convert` command documentation](/cdktf/cli-reference/commands#convert) for more information.
