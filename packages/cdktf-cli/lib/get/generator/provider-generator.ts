import { CodeMaker } from "codemaker";
import { Provider, ProviderSchema } from "./provider-schema";
import { ResourceModel } from "./models";
import { ResourceParser } from "./resource-parser";
import { ResourceEmitter, StructEmitter } from "./emitter";
import { ConstructsMakerTarget } from "../constructs-maker";
import { Errors } from "../../errors";

interface ProviderData {
  name: string;
  source: string;
  version: string;
}

const isMatching = (
  target: ConstructsMakerTarget,
  terraformSchemaName: string
): boolean => {
  if (target.isModule) return false;

  const elements = terraformSchemaName.split("/");

  if (elements.length === 1) {
    return target.source === terraformSchemaName;
  } else {
    const [hostname, scope, provider] = elements;

    if (!hostname || !scope || !provider) {
      throw Errors.Internal("get", `can't handle ${terraformSchemaName}`);
    }

    return target.name === provider;
  }
};

function namespaceExportName(value: string) {
  if (value === "default") {
    return "_default";
  }
  return value;
}

export interface ProviderConstraints {
  [fqn: string]: ProviderData;
}

export class TerraformProviderGenerator {
  private resourceParser = new ResourceParser();
  private resourceEmitter: ResourceEmitter;
  private structEmitter: StructEmitter;
  constructor(
    private readonly code: CodeMaker,
    schema: ProviderSchema,
    private providerConstraints?: ConstructsMakerTarget[]
  ) {
    this.code.indentation = 2;
    this.resourceEmitter = new ResourceEmitter(this.code);
    this.structEmitter = new StructEmitter(this.code);

    if (!schema.provider_schemas) {
      console.info("no providers - nothing to do");
      return;
    }

    for (const [fqpn, provider] of Object.entries(schema.provider_schemas)) {
      if (
        this.providerConstraints &&
        this.providerConstraints.find((p) => isMatching(p, fqpn))
      ) {
        this.emitProvider(fqpn, provider);
      } else if (!this.providerConstraints) {
        this.emitProvider(fqpn, provider);
      }
    }
  }

  public async save(outdir: string) {
    await this.code.save(outdir);
  }

  private emitProvider(fqpn: string, provider: Provider) {
    const name = fqpn.split("/").pop();
    if (!name) {
      throw Errors.Internal("get", `can't handle ${fqpn}`, { fqpn });
    }

    // If we have over X resources, we'll need to split the files
    const resourceCount = Object.keys({
      ...provider.resource_schemas,
      ...provider.data_source_schemas,
    }).length;
    if (resourceCount > 300) {
      this.resourceParser.split = true;
    }

    const files: string[] = [];
    for (const [type, resource] of Object.entries(
      provider.resource_schemas || []
    )) {
      files.push(
        this.emitResourceFile(
          this.resourceParser.parse(name, type, resource, "resource")
        )
      );
    }

    for (const [type, resource] of Object.entries(
      provider.data_source_schemas || []
    )) {
      files.push(
        this.emitResourceFile(
          this.resourceParser.parse(
            name,
            `data_${type}`,
            resource,
            "data_source"
          )
        )
      );
    }

    if (provider.provider) {
      const providerResource = this.resourceParser.parse(
        name,
        `provider`,
        provider.provider,
        "provider"
      );
      if (this.providerConstraints) {
        const constraint = this.providerConstraints.find((p) =>
          isMatching(p, fqpn)
        );
        if (!constraint) {
          throw Errors.Internal("get", `can't handle ${fqpn}`);
        }
        providerResource.providerVersionConstraint = constraint.version;
        providerResource.terraformProviderSource = constraint.source;
      }
      files.push(this.emitResourceFile(providerResource));
    }

    this.emitRecursiveIndexFile(`providers/${name}`, files);
  }

  private emitRecursiveIndexFile(folder: string, files: string[]): void {
    const filePath = `${folder}/index.ts`;
    function submoduleName(p: string): string | null {
      const firstPart = p.replace(`${folder}/`, "").split("/")[0];
      if (firstPart.includes(".ts")) {
        return null;
      }
      return firstPart;
    }

    this.code.openFile(filePath);
    this.code.line("// generated by cdktf get");

    const starExports: string[] = [];
    const subModuleExports = files.reduce((acc, file) => {
      const submodule = submoduleName(file);
      if (submodule) {
        acc[submodule] = [...(acc[submodule] || []), file];
      } else {
        starExports.push(file);
      }

      return acc;
    }, {} as { [submodulePath: string]: string[] });

    for (const submodule of Object.keys(subModuleExports)) {
      this.code.line(
        `export * as ${namespaceExportName(submodule)} from './${submodule}';`
      );
    }
    for (const file of starExports) {
      this.code.line(
        `export * from './${file
          .replace(`${folder}/`, "")
          .replace(".ts", "")}';`
      );
    }

    this.code.line();
    this.code.closeFile(filePath);

    // Generate index files for submodules
    Object.entries(subModuleExports).forEach(([submodule, files]) => {
      if (submodule === "data") {
        this.emitRecursiveIndexFile(`${folder}/${submodule}`, files);
      } else {
        this.emitIndexFile(folder, submodule, files);
      }
    });
  }

  private emitIndexFile(
    folderPath: string,
    submodule: string,
    files: string[]
  ): void {
    const filePath = `${folderPath}/${submodule}/index.ts`;
    this.code.openFile(filePath);
    this.code.line("// generated by cdktf get");
    for (const file of files) {
      this.code.line(
        `export * from './${file
          .replace(`${folderPath}/`, "")
          .replace(`${submodule}/`, "")
          .replace(".ts", "")}';`
      );
    }
    this.code.line();
    this.code.closeFile(filePath);
  }

  private emitResourceFile(resource: ResourceModel): string {
    this.code.openFile(resource.filePath);
    this.emitFileHeader(resource);
    this.structEmitter.emit(resource);
    this.resourceEmitter.emit(resource);
    this.code.closeFile(resource.filePath);

    return resource.filePath;
  }

  private emitFileHeader(resource: ResourceModel) {
    this.code.line(`// ${resource.linkToDocs}`);
    this.code.line(`// generated from terraform resource schema`);
    this.code.line();
    resource.importStatements.forEach((statement) => this.code.line(statement));
    this.code.line();
    this.code.line("// Configuration");
    this.code.line();
  }
}
