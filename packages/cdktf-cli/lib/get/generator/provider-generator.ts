import { CodeMaker } from 'codemaker';
import { Provider, ProviderSchema } from './provider-schema';
import { ResourceModel } from "./models"
import { ResourceParser } from './resource-parser'
import { ResourceEmitter, StructEmitter } from './emitter'

export class TerraformProviderConstraint {
  public version: string;
  public source?: string;
  public name: string
  public fqn:  string;

  constructor(public cdktfConstraint: string) {
    const [ fqn, version ] = cdktfConstraint.split('@');
    const nameParts = fqn.split('/');
    const name = nameParts.pop();
    if (!name) { throw new Error(`Provider name should be properly set in ${cdktfConstraint}`) }

    this.name = name;
    this.source = nameParts.join('/');
    this.version = version;
    this.fqn = fqn
  }

  public isMatching(terraformSchemaName: string): boolean {
    const elements = terraformSchemaName.split('/')

    if (elements.length === 1) {
      return this.name === terraformSchemaName
    } else {
      const [hostname, scope, provider] = elements

      if (!hostname || !scope || !provider) {
        throw new Error(`can't handle ${terraformSchemaName}`)
      }

      return this.name === provider;
    }
  }
}
interface ProviderData {
  name: string;
  source: string;
  version: string;
}

export interface ProviderConstraints {
  [fqn: string]: ProviderData;
}

export class TerraformGenerator {
  private resourceParser = new ResourceParser();
  private resourceEmitter:  ResourceEmitter;
  private structEmitter:  StructEmitter;
  constructor(private readonly code: CodeMaker, schema: ProviderSchema, private providerConstraints?: TerraformProviderConstraint[]) {

    this.code.indentation = 2;
    this.resourceEmitter = new ResourceEmitter(this.code)
    this.structEmitter = new StructEmitter(this.code)

    if (!schema.provider_schemas) {
      console.error('warning: no providers');
      return;
    }

    for (const [fqpn, provider] of Object.entries(schema.provider_schemas)) {
      this.emitProvider(fqpn, provider);
    }
  }

  public async save(outdir: string) {
    await this.code.save(outdir);
  }

  private emitProvider(fqpn: string, provider: Provider) {
    const name = fqpn.split('/').pop()
    if (!name) { throw new Error(`can't handle ${fqpn}`) }

    const files: string[] = []
    for (const [type, resource] of Object.entries(provider.resource_schemas)) {
      files.push(this.emitResourceFile(this.resourceParser.parse(name, type, resource, 'resource')));
    }

    for (const [type, resource] of Object.entries(provider.data_source_schemas || [])) {
      files.push(this.emitResourceFile(this.resourceParser.parse(name, `data_${type}`, resource, 'data_source')));
    }

    if (provider.provider) {
      const providerResource = this.resourceParser.parse(name, `provider`, provider.provider, 'provider')
      if (this.providerConstraints) {
        const constraint = this.providerConstraints.find((p) => (p.isMatching(fqpn)))
        if (!constraint) {
          console.log({foo: this.providerConstraints, fqpn})
          throw new Error(`can't handle ${fqpn}`)
        }
        providerResource.providerVersionConstraint = constraint.version;
        providerResource.terraformProviderSource = constraint.fqn;
      }
      files.push(this.emitResourceFile(providerResource));
    }

    this.emitIndexFile(name, files)
  }

  private emitIndexFile(provider: string, files: string[]): void {
    const folder = `providers/${provider}`
    const filePath = `${folder}/index.ts`
    this.code.openFile(filePath);
    this.code.line('// generated by cdktf get')
    for (const file of files) {
      this.code.line(`export * from './${file.replace(`${folder}/`, '').replace('.ts', '')}';`);
    }
    this.code.line()
    this.code.closeFile(filePath)
  }

  private emitResourceFile(resource: ResourceModel): string {
    this.code.openFile(resource.filePath);
      this.emitFileHeader(resource)
      this.structEmitter.emit(resource);
      this.resourceEmitter.emit(resource)
    this.code.closeFile(resource.filePath);

    return resource.filePath;
  }

  private emitFileHeader(resource: ResourceModel) {
    this.code.line(`// ${resource.linkToDocs}`);
    this.code.line(`// generated from terraform resource schema`);
    this.code.line();
    resource.importStatements.forEach(statement => this.code.line(statement))
    this.code.line();
    this.code.line('// Configuration');
    this.code.line();
  }
}