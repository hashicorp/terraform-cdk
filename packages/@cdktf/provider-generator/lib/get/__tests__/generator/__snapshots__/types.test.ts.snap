// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`boolean list attribute 1`] = `
"// https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/boolean_list
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface BooleanListConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/boolean_list#foo_required BooleanList#foo_required}
  */
  readonly fooRequired: Array<boolean | cdktf.IResolvable> | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/boolean_list#foo_optional BooleanList#foo_optional}
  */
  readonly fooOptional?: Array<boolean | cdktf.IResolvable> | cdktf.IResolvable;
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/boolean_list aws_boolean_list}
*/
export class BooleanList extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aws_boolean_list";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a BooleanList resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the BooleanList to import
  * @param importFromId The id of the existing BooleanList that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/boolean_list#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the BooleanList to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aws_boolean_list", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/boolean_list aws_boolean_list} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options BooleanListConfig
  */
  public constructor(scope: Construct, id: string, config: BooleanListConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_boolean_list',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._fooRequired = config.fooRequired;
    this._fooOptional = config.fooOptional;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_required - computed: false, optional: false, required: true
  private _fooRequired?: Array<boolean | cdktf.IResolvable> | cdktf.IResolvable; 
  public get fooRequired() {
    return this.interpolationForAttribute('foo_required');
  }
  public set fooRequired(value: Array<boolean | cdktf.IResolvable> | cdktf.IResolvable) {
    this._fooRequired = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fooRequiredInput() {
    return this._fooRequired;
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional?: Array<boolean | cdktf.IResolvable> | cdktf.IResolvable; 
  public get fooOptional() {
    return this.interpolationForAttribute('foo_optional');
  }
  public set fooOptional(value: Array<boolean | cdktf.IResolvable> | cdktf.IResolvable) {
    this._fooOptional = value;
  }
  public resetFooOptional() {
    this._fooOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooOptionalInput() {
    return this._fooOptional;
  }

  // foo_computed - computed: true, optional: false, required: false
  private _fooComputed = new cdktf.BooleanList(this, "foo_computed", false);
  public get fooComputed() {
    return this._fooComputed;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_required: cdktf.listMapper(cdktf.booleanToTerraform, false)(this._fooRequired),
      foo_optional: cdktf.listMapper(cdktf.booleanToTerraform, false)(this._fooOptional),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      foo_required: {
        value: cdktf.listMapperHcl(cdktf.booleanToHclTerraform, false)(this._fooRequired),
        isBlock: false,
        type: "list",
        storageClassType: "booleanList",
      },
      foo_optional: {
        value: cdktf.listMapperHcl(cdktf.booleanToHclTerraform, false)(this._fooOptional),
        isBlock: false,
        type: "list",
        storageClassType: "booleanList",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`boolean map attribute 1`] = `
"// https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/boolean_map
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface BooleanMapConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/boolean_map#foo_computed_optional BooleanMap#foo_computed_optional}
  */
  readonly fooComputedOptional?: { [key: string]: (boolean | cdktf.IResolvable) };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/boolean_map#foo_optional BooleanMap#foo_optional}
  */
  readonly fooOptional?: { [key: string]: (boolean | cdktf.IResolvable) };
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/boolean_map aws_boolean_map}
*/
export class BooleanMap extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aws_boolean_map";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a BooleanMap resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the BooleanMap to import
  * @param importFromId The id of the existing BooleanMap that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/boolean_map#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the BooleanMap to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aws_boolean_map", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/boolean_map aws_boolean_map} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options BooleanMapConfig = {}
  */
  public constructor(scope: Construct, id: string, config: BooleanMapConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_boolean_map',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._fooComputedOptional = config.fooComputedOptional;
    this._fooOptional = config.fooOptional;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_computed - computed: true, optional: false, required: false
  private _fooComputed = new cdktf.BooleanMap(this, "foo_computed");
  public get fooComputed() {
    return this._fooComputed;
  }

  // foo_computed_optional - computed: true, optional: true, required: false
  private _fooComputedOptional?: { [key: string]: (boolean | cdktf.IResolvable) }; 
  public get fooComputedOptional() {
    return this.getBooleanMapAttribute('foo_computed_optional');
  }
  public set fooComputedOptional(value: { [key: string]: (boolean | cdktf.IResolvable) }) {
    this._fooComputedOptional = value;
  }
  public resetFooComputedOptional() {
    this._fooComputedOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooComputedOptionalInput() {
    return this._fooComputedOptional;
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional?: { [key: string]: (boolean | cdktf.IResolvable) }; 
  public get fooOptional() {
    return this.getBooleanMapAttribute('foo_optional');
  }
  public set fooOptional(value: { [key: string]: (boolean | cdktf.IResolvable) }) {
    this._fooOptional = value;
  }
  public resetFooOptional() {
    this._fooOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooOptionalInput() {
    return this._fooOptional;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_computed_optional: cdktf.hashMapper(cdktf.booleanToTerraform)(this._fooComputedOptional),
      foo_optional: cdktf.hashMapper(cdktf.booleanToTerraform)(this._fooOptional),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      foo_computed_optional: {
        value: cdktf.hashMapperHcl(cdktf.booleanToHclTerraform)(this._fooComputedOptional),
        isBlock: false,
        type: "map",
        storageClassType: "booleanMap",
      },
      foo_optional: {
        value: cdktf.hashMapperHcl(cdktf.booleanToHclTerraform)(this._fooOptional),
        isBlock: false,
        type: "map",
        storageClassType: "booleanMap",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`computed complex attribute 1`] = `
"// https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/computed_complex
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface ComputedComplexConfig extends cdktf.TerraformMetaArguments {
}
export interface ComputedComplexEgress {
}

export function computedComplexEgressToTerraform(struct?: ComputedComplexEgress): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function computedComplexEgressToHclTerraform(struct?: ComputedComplexEgress): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class ComputedComplexEgressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ComputedComplexEgress | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ComputedComplexEgress | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // cidr_blocks - computed: true, optional: false, required: false
  public get cidrBlocks() {
    return this.getListAttribute('cidr_blocks');
  }

  // description - computed: true, optional: false, required: false
  public get description() {
    return this.getStringAttribute('description');
  }

  // from_port - computed: true, optional: false, required: false
  public get fromPort() {
    return this.getNumberAttribute('from_port');
  }

  // ipv6_cidr_blocks - computed: true, optional: false, required: false
  public get ipv6CidrBlocks() {
    return this.getListAttribute('ipv6_cidr_blocks');
  }

  // prefix_list_ids - computed: true, optional: false, required: false
  public get prefixListIds() {
    return this.getListAttribute('prefix_list_ids');
  }

  // protocol - computed: true, optional: false, required: false
  public get protocol() {
    return this.getStringAttribute('protocol');
  }

  // security_groups - computed: true, optional: false, required: false
  public get securityGroups() {
    return cdktf.Fn.tolist(this.getListAttribute('security_groups'));
  }

  // self - computed: true, optional: false, required: false
  public get selfAttribute() {
    return this.getBooleanAttribute('self');
  }

  // to_port - computed: true, optional: false, required: false
  public get toPort() {
    return this.getNumberAttribute('to_port');
  }
}

export class ComputedComplexEgressList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ComputedComplexEgressOutputReference {
    return new ComputedComplexEgressOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/computed_complex aws_computed_complex}
*/
export class ComputedComplex extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aws_computed_complex";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a ComputedComplex resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the ComputedComplex to import
  * @param importFromId The id of the existing ComputedComplex that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/computed_complex#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the ComputedComplex to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aws_computed_complex", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/computed_complex aws_computed_complex} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options ComputedComplexConfig = {}
  */
  public constructor(scope: Construct, id: string, config: ComputedComplexConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_computed_complex',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // egress - computed: true, optional: false, required: false
  private _egress = new ComputedComplexEgressList(this, "egress", true);
  public get egress() {
    return this._egress;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
    };
    return attrs;
  }
}
"
`;

exports[`computed complex nested attribute 1`] = `
"// https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/computed_complex_nested
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface ComputedComplexNestedConfig extends cdktf.TerraformMetaArguments {
}
export interface ComputedComplexNestedResourcesAutoscalingGroups {
}

export function computedComplexNestedResourcesAutoscalingGroupsToTerraform(struct?: ComputedComplexNestedResourcesAutoscalingGroups): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function computedComplexNestedResourcesAutoscalingGroupsToHclTerraform(struct?: ComputedComplexNestedResourcesAutoscalingGroups): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class ComputedComplexNestedResourcesAutoscalingGroupsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ComputedComplexNestedResourcesAutoscalingGroups | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ComputedComplexNestedResourcesAutoscalingGroups | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // name - computed: true, optional: false, required: false
  public get name() {
    return this.getStringAttribute('name');
  }
}

export class ComputedComplexNestedResourcesAutoscalingGroupsList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ComputedComplexNestedResourcesAutoscalingGroupsOutputReference {
    return new ComputedComplexNestedResourcesAutoscalingGroupsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ComputedComplexNestedResources {
}

export function computedComplexNestedResourcesToTerraform(struct?: ComputedComplexNestedResources): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function computedComplexNestedResourcesToHclTerraform(struct?: ComputedComplexNestedResources): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class ComputedComplexNestedResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ComputedComplexNestedResources | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ComputedComplexNestedResources | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // autoscaling_groups - computed: true, optional: false, required: false
  private _autoscalingGroups = new ComputedComplexNestedResourcesAutoscalingGroupsList(this, "autoscaling_groups", false);
  public get autoscalingGroups() {
    return this._autoscalingGroups;
  }

  // remote_access_security_group_id - computed: true, optional: false, required: false
  public get remoteAccessSecurityGroupId() {
    return this.getStringAttribute('remote_access_security_group_id');
  }
}

export class ComputedComplexNestedResourcesList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ComputedComplexNestedResourcesOutputReference {
    return new ComputedComplexNestedResourcesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/computed_complex_nested aws_computed_complex_nested}
*/
export class ComputedComplexNested extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aws_computed_complex_nested";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a ComputedComplexNested resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the ComputedComplexNested to import
  * @param importFromId The id of the existing ComputedComplexNested that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/computed_complex_nested#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the ComputedComplexNested to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aws_computed_complex_nested", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/computed_complex_nested aws_computed_complex_nested} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options ComputedComplexNestedConfig = {}
  */
  public constructor(scope: Construct, id: string, config: ComputedComplexNestedConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_computed_complex_nested',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // resources - computed: true, optional: false, required: false
  private _resources = new ComputedComplexNestedResourcesList(this, "resources", false);
  public get resources() {
    return this._resources;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
    };
    return attrs;
  }
}
"
`;

exports[`computed nested complex list block type 1`] = `
"// https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/block_type_nested_computed_list
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface BlockTypeNestedComputedListConfig extends cdktf.TerraformMetaArguments {
  /**
  * inputs block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/block_type_nested_computed_list#inputs BlockTypeNestedComputedList#inputs}
  */
  readonly inputs?: BlockTypeNestedComputedListInputs[] | cdktf.IResolvable;
}
export interface BlockTypeNestedComputedListInputsStartingPositionConfiguration {
}

export function blockTypeNestedComputedListInputsStartingPositionConfigurationToTerraform(struct?: BlockTypeNestedComputedListInputsStartingPositionConfiguration): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function blockTypeNestedComputedListInputsStartingPositionConfigurationToHclTerraform(struct?: BlockTypeNestedComputedListInputsStartingPositionConfiguration): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class BlockTypeNestedComputedListInputsStartingPositionConfigurationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): BlockTypeNestedComputedListInputsStartingPositionConfiguration | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: BlockTypeNestedComputedListInputsStartingPositionConfiguration | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // starting_position - computed: true, optional: false, required: false
  public get startingPosition() {
    return this.getStringAttribute('starting_position');
  }
}

export class BlockTypeNestedComputedListInputsStartingPositionConfigurationList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): BlockTypeNestedComputedListInputsStartingPositionConfigurationOutputReference {
    return new BlockTypeNestedComputedListInputsStartingPositionConfigurationOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface BlockTypeNestedComputedListInputs {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/block_type_nested_computed_list#name_prefix BlockTypeNestedComputedList#name_prefix}
  */
  readonly namePrefix: string;
}

export function blockTypeNestedComputedListInputsToTerraform(struct?: BlockTypeNestedComputedListInputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name_prefix: cdktf.stringToTerraform(struct!.namePrefix),
  }
}


export function blockTypeNestedComputedListInputsToHclTerraform(struct?: BlockTypeNestedComputedListInputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name_prefix: {
      value: cdktf.stringToHclTerraform(struct!.namePrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class BlockTypeNestedComputedListInputsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): BlockTypeNestedComputedListInputs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._namePrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.namePrefix = this._namePrefix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: BlockTypeNestedComputedListInputs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._namePrefix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._namePrefix = value.namePrefix;
    }
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getStringAttribute('id');
  }

  // name_prefix - computed: false, optional: false, required: true
  private _namePrefix?: string; 
  public get namePrefix() {
    return this.getStringAttribute('name_prefix');
  }
  public set namePrefix(value: string) {
    this._namePrefix = value;
  }
  // Temporarily expose input value. Use with caution.
  public get namePrefixInput() {
    return this._namePrefix;
  }

  // starting_position_configuration - computed: true, optional: false, required: false
  private _startingPositionConfiguration = new BlockTypeNestedComputedListInputsStartingPositionConfigurationList(this, "starting_position_configuration", false);
  public get startingPositionConfiguration() {
    return this._startingPositionConfiguration;
  }

  // stream_names - computed: true, optional: false, required: false
  public get streamNames() {
    return cdktf.Fn.tolist(this.getListAttribute('stream_names'));
  }
}

export class BlockTypeNestedComputedListInputsList extends cdktf.ComplexList {
  public internalValue? : BlockTypeNestedComputedListInputs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): BlockTypeNestedComputedListInputsOutputReference {
    return new BlockTypeNestedComputedListInputsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/block_type_nested_computed_list aws_block_type_nested_computed_list}
*/
export class BlockTypeNestedComputedList extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aws_block_type_nested_computed_list";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a BlockTypeNestedComputedList resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the BlockTypeNestedComputedList to import
  * @param importFromId The id of the existing BlockTypeNestedComputedList that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/block_type_nested_computed_list#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the BlockTypeNestedComputedList to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aws_block_type_nested_computed_list", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/block_type_nested_computed_list aws_block_type_nested_computed_list} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options BlockTypeNestedComputedListConfig = {}
  */
  public constructor(scope: Construct, id: string, config: BlockTypeNestedComputedListConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_block_type_nested_computed_list',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._inputs.internalValue = config.inputs;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // inputs - computed: false, optional: true, required: false
  private _inputs = new BlockTypeNestedComputedListInputsList(this, "inputs", false);
  public get inputs() {
    return this._inputs;
  }
  public putInputs(value: BlockTypeNestedComputedListInputs[] | cdktf.IResolvable) {
    this._inputs.internalValue = value;
  }
  public resetInputs() {
    this._inputs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inputsInput() {
    return this._inputs.internalValue;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      inputs: cdktf.listMapper(blockTypeNestedComputedListInputsToTerraform, true)(this._inputs.internalValue),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      inputs: {
        value: cdktf.listMapperHcl(blockTypeNestedComputedListInputsToHclTerraform, true)(this._inputs.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "BlockTypeNestedComputedListInputsList",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`computed optional complex attribute 1`] = `
"// https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/computed_optional_complex
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface ComputedOptionalComplexConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/computed_optional_complex#egress ComputedOptionalComplex#egress}
  */
  readonly egress?: ComputedOptionalComplexEgress[] | cdktf.IResolvable;
}
export interface ComputedOptionalComplexEgress {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/computed_optional_complex#cidr_blocks ComputedOptionalComplex#cidr_blocks}
  */
  readonly cidrBlocks?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/computed_optional_complex#description ComputedOptionalComplex#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/computed_optional_complex#from_port ComputedOptionalComplex#from_port}
  */
  readonly fromPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/computed_optional_complex#ipv6_cidr_blocks ComputedOptionalComplex#ipv6_cidr_blocks}
  */
  readonly ipv6CidrBlocks?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/computed_optional_complex#prefix_list_ids ComputedOptionalComplex#prefix_list_ids}
  */
  readonly prefixListIds?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/computed_optional_complex#protocol ComputedOptionalComplex#protocol}
  */
  readonly protocol?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/computed_optional_complex#security_groups ComputedOptionalComplex#security_groups}
  */
  readonly securityGroups?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/computed_optional_complex#self ComputedOptionalComplex#self}
  */
  readonly selfAttribute?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/computed_optional_complex#to_port ComputedOptionalComplex#to_port}
  */
  readonly toPort?: number;
}

export function computedOptionalComplexEgressToTerraform(struct?: ComputedOptionalComplexEgress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cidr_blocks: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.cidrBlocks),
    description: cdktf.stringToTerraform(struct!.description),
    from_port: cdktf.numberToTerraform(struct!.fromPort),
    ipv6_cidr_blocks: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.ipv6CidrBlocks),
    prefix_list_ids: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.prefixListIds),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    security_groups: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.securityGroups),
    self: cdktf.booleanToTerraform(struct!.selfAttribute),
    to_port: cdktf.numberToTerraform(struct!.toPort),
  }
}


export function computedOptionalComplexEgressToHclTerraform(struct?: ComputedOptionalComplexEgress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cidr_blocks: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.cidrBlocks),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    from_port: {
      value: cdktf.numberToHclTerraform(struct!.fromPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ipv6_cidr_blocks: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.ipv6CidrBlocks),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    prefix_list_ids: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.prefixListIds),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    security_groups: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.securityGroups),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    self: {
      value: cdktf.booleanToHclTerraform(struct!.selfAttribute),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    to_port: {
      value: cdktf.numberToHclTerraform(struct!.toPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ComputedOptionalComplexEgressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ComputedOptionalComplexEgress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cidrBlocks !== undefined) {
      hasAnyValues = true;
      internalValueResult.cidrBlocks = this._cidrBlocks;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._fromPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.fromPort = this._fromPort;
    }
    if (this._ipv6CidrBlocks !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6CidrBlocks = this._ipv6CidrBlocks;
    }
    if (this._prefixListIds !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixListIds = this._prefixListIds;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._securityGroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.securityGroups = this._securityGroups;
    }
    if (this._self !== undefined) {
      hasAnyValues = true;
      internalValueResult.selfAttribute = this._self;
    }
    if (this._toPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.toPort = this._toPort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ComputedOptionalComplexEgress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cidrBlocks = undefined;
      this._description = undefined;
      this._fromPort = undefined;
      this._ipv6CidrBlocks = undefined;
      this._prefixListIds = undefined;
      this._protocol = undefined;
      this._securityGroups = undefined;
      this._self = undefined;
      this._toPort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cidrBlocks = value.cidrBlocks;
      this._description = value.description;
      this._fromPort = value.fromPort;
      this._ipv6CidrBlocks = value.ipv6CidrBlocks;
      this._prefixListIds = value.prefixListIds;
      this._protocol = value.protocol;
      this._securityGroups = value.securityGroups;
      this._self = value.selfAttribute;
      this._toPort = value.toPort;
    }
  }

  // cidr_blocks - computed: true, optional: true, required: false
  private _cidrBlocks?: string[]; 
  public get cidrBlocks() {
    return this.getListAttribute('cidr_blocks');
  }
  public set cidrBlocks(value: string[]) {
    this._cidrBlocks = value;
  }
  public resetCidrBlocks() {
    this._cidrBlocks = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cidrBlocksInput() {
    return this._cidrBlocks;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // from_port - computed: true, optional: true, required: false
  private _fromPort?: number; 
  public get fromPort() {
    return this.getNumberAttribute('from_port');
  }
  public set fromPort(value: number) {
    this._fromPort = value;
  }
  public resetFromPort() {
    this._fromPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromPortInput() {
    return this._fromPort;
  }

  // ipv6_cidr_blocks - computed: true, optional: true, required: false
  private _ipv6CidrBlocks?: string[]; 
  public get ipv6CidrBlocks() {
    return this.getListAttribute('ipv6_cidr_blocks');
  }
  public set ipv6CidrBlocks(value: string[]) {
    this._ipv6CidrBlocks = value;
  }
  public resetIpv6CidrBlocks() {
    this._ipv6CidrBlocks = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6CidrBlocksInput() {
    return this._ipv6CidrBlocks;
  }

  // prefix_list_ids - computed: true, optional: true, required: false
  private _prefixListIds?: string[]; 
  public get prefixListIds() {
    return this.getListAttribute('prefix_list_ids');
  }
  public set prefixListIds(value: string[]) {
    this._prefixListIds = value;
  }
  public resetPrefixListIds() {
    this._prefixListIds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListIdsInput() {
    return this._prefixListIds;
  }

  // protocol - computed: true, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // security_groups - computed: true, optional: true, required: false
  private _securityGroups?: string[]; 
  public get securityGroups() {
    return cdktf.Fn.tolist(this.getListAttribute('security_groups'));
  }
  public set securityGroups(value: string[]) {
    this._securityGroups = value;
  }
  public resetSecurityGroups() {
    this._securityGroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get securityGroupsInput() {
    return this._securityGroups;
  }

  // self - computed: true, optional: true, required: false
  private _self?: boolean | cdktf.IResolvable; 
  public get selfAttribute() {
    return this.getBooleanAttribute('self');
  }
  public set selfAttribute(value: boolean | cdktf.IResolvable) {
    this._self = value;
  }
  public resetSelfAttribute() {
    this._self = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selfAttributeInput() {
    return this._self;
  }

  // to_port - computed: true, optional: true, required: false
  private _toPort?: number; 
  public get toPort() {
    return this.getNumberAttribute('to_port');
  }
  public set toPort(value: number) {
    this._toPort = value;
  }
  public resetToPort() {
    this._toPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toPortInput() {
    return this._toPort;
  }
}

export class ComputedOptionalComplexEgressList extends cdktf.ComplexList {
  public internalValue? : ComputedOptionalComplexEgress[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ComputedOptionalComplexEgressOutputReference {
    return new ComputedOptionalComplexEgressOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/computed_optional_complex aws_computed_optional_complex}
*/
export class ComputedOptionalComplex extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aws_computed_optional_complex";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a ComputedOptionalComplex resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the ComputedOptionalComplex to import
  * @param importFromId The id of the existing ComputedOptionalComplex that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/computed_optional_complex#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the ComputedOptionalComplex to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aws_computed_optional_complex", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/computed_optional_complex aws_computed_optional_complex} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options ComputedOptionalComplexConfig = {}
  */
  public constructor(scope: Construct, id: string, config: ComputedOptionalComplexConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_computed_optional_complex',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._egress.internalValue = config.egress;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // egress - computed: true, optional: true, required: false
  private _egress = new ComputedOptionalComplexEgressList(this, "egress", true);
  public get egress() {
    return this._egress;
  }
  public putEgress(value: ComputedOptionalComplexEgress[] | cdktf.IResolvable) {
    this._egress.internalValue = value;
  }
  public resetEgress() {
    this._egress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressInput() {
    return this._egress.internalValue;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      egress: cdktf.listMapper(computedOptionalComplexEgressToTerraform, false)(this._egress.internalValue),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      egress: {
        value: cdktf.listMapperHcl(computedOptionalComplexEgressToHclTerraform, false)(this._egress.internalValue),
        isBlock: true,
        type: "set",
        storageClassType: "ComputedOptionalComplexEgressList",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`deeply nested block types 1`] = `
"// https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/deeply_nested_block_types
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface DeeplyNestedBlockTypesConfig extends cdktf.TerraformMetaArguments {
  /**
  * lifecycle_rule block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/deeply_nested_block_types#lifecycle_rule DeeplyNestedBlockTypes#lifecycle_rule}
  */
  readonly lifecycleRule?: DeeplyNestedBlockTypesLifecycleRule[] | cdktf.IResolvable;
}
export interface DeeplyNestedBlockTypesLifecycleRuleExpiration {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/deeply_nested_block_types#date DeeplyNestedBlockTypes#date}
  */
  readonly date?: string;
}

export function deeplyNestedBlockTypesLifecycleRuleExpirationToTerraform(struct?: DeeplyNestedBlockTypesLifecycleRuleExpirationOutputReference | DeeplyNestedBlockTypesLifecycleRuleExpiration): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    date: cdktf.stringToTerraform(struct!.date),
  }
}


export function deeplyNestedBlockTypesLifecycleRuleExpirationToHclTerraform(struct?: DeeplyNestedBlockTypesLifecycleRuleExpirationOutputReference | DeeplyNestedBlockTypesLifecycleRuleExpiration): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    date: {
      value: cdktf.stringToHclTerraform(struct!.date),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeeplyNestedBlockTypesLifecycleRuleExpirationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DeeplyNestedBlockTypesLifecycleRuleExpiration | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._date !== undefined) {
      hasAnyValues = true;
      internalValueResult.date = this._date;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeeplyNestedBlockTypesLifecycleRuleExpiration | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._date = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._date = value.date;
    }
  }

  // date - computed: false, optional: true, required: false
  private _date?: string; 
  public get date() {
    return this.getStringAttribute('date');
  }
  public set date(value: string) {
    this._date = value;
  }
  public resetDate() {
    this._date = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dateInput() {
    return this._date;
  }
}
export interface DeeplyNestedBlockTypesLifecycleRule {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/deeply_nested_block_types#abort_incomplete_multipart_upload_days DeeplyNestedBlockTypes#abort_incomplete_multipart_upload_days}
  */
  readonly abortIncompleteMultipartUploadDays?: number;
  /**
  * expiration block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/deeply_nested_block_types#expiration DeeplyNestedBlockTypes#expiration}
  */
  readonly expiration?: DeeplyNestedBlockTypesLifecycleRuleExpiration;
}

export function deeplyNestedBlockTypesLifecycleRuleToTerraform(struct?: DeeplyNestedBlockTypesLifecycleRule | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    abort_incomplete_multipart_upload_days: cdktf.numberToTerraform(struct!.abortIncompleteMultipartUploadDays),
    expiration: deeplyNestedBlockTypesLifecycleRuleExpirationToTerraform(struct!.expiration),
  }
}


export function deeplyNestedBlockTypesLifecycleRuleToHclTerraform(struct?: DeeplyNestedBlockTypesLifecycleRule | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    abort_incomplete_multipart_upload_days: {
      value: cdktf.numberToHclTerraform(struct!.abortIncompleteMultipartUploadDays),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    expiration: {
      value: deeplyNestedBlockTypesLifecycleRuleExpirationToHclTerraform(struct!.expiration),
      isBlock: true,
      type: "set",
      storageClassType: "DeeplyNestedBlockTypesLifecycleRuleExpirationList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeeplyNestedBlockTypesLifecycleRuleOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeeplyNestedBlockTypesLifecycleRule | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._abortIncompleteMultipartUploadDays !== undefined) {
      hasAnyValues = true;
      internalValueResult.abortIncompleteMultipartUploadDays = this._abortIncompleteMultipartUploadDays;
    }
    if (this._expiration?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.expiration = this._expiration?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeeplyNestedBlockTypesLifecycleRule | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._abortIncompleteMultipartUploadDays = undefined;
      this._expiration.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._abortIncompleteMultipartUploadDays = value.abortIncompleteMultipartUploadDays;
      this._expiration.internalValue = value.expiration;
    }
  }

  // abort_incomplete_multipart_upload_days - computed: false, optional: true, required: false
  private _abortIncompleteMultipartUploadDays?: number; 
  public get abortIncompleteMultipartUploadDays() {
    return this.getNumberAttribute('abort_incomplete_multipart_upload_days');
  }
  public set abortIncompleteMultipartUploadDays(value: number) {
    this._abortIncompleteMultipartUploadDays = value;
  }
  public resetAbortIncompleteMultipartUploadDays() {
    this._abortIncompleteMultipartUploadDays = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get abortIncompleteMultipartUploadDaysInput() {
    return this._abortIncompleteMultipartUploadDays;
  }

  // expiration - computed: false, optional: true, required: false
  private _expiration = new DeeplyNestedBlockTypesLifecycleRuleExpirationOutputReference(this, "expiration");
  public get expiration() {
    return this._expiration;
  }
  public putExpiration(value: DeeplyNestedBlockTypesLifecycleRuleExpiration) {
    this._expiration.internalValue = value;
  }
  public resetExpiration() {
    this._expiration.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expirationInput() {
    return this._expiration.internalValue;
  }
}

export class DeeplyNestedBlockTypesLifecycleRuleList extends cdktf.ComplexList {
  public internalValue? : DeeplyNestedBlockTypesLifecycleRule[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeeplyNestedBlockTypesLifecycleRuleOutputReference {
    return new DeeplyNestedBlockTypesLifecycleRuleOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/deeply_nested_block_types aws_deeply_nested_block_types}
*/
export class DeeplyNestedBlockTypes extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aws_deeply_nested_block_types";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a DeeplyNestedBlockTypes resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the DeeplyNestedBlockTypes to import
  * @param importFromId The id of the existing DeeplyNestedBlockTypes that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/deeply_nested_block_types#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the DeeplyNestedBlockTypes to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aws_deeply_nested_block_types", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/deeply_nested_block_types aws_deeply_nested_block_types} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options DeeplyNestedBlockTypesConfig = {}
  */
  public constructor(scope: Construct, id: string, config: DeeplyNestedBlockTypesConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_deeply_nested_block_types',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._lifecycleRule.internalValue = config.lifecycleRule;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // lifecycle_rule - computed: false, optional: true, required: false
  private _lifecycleRule = new DeeplyNestedBlockTypesLifecycleRuleList(this, "lifecycle_rule", false);
  public get lifecycleRule() {
    return this._lifecycleRule;
  }
  public putLifecycleRule(value: DeeplyNestedBlockTypesLifecycleRule[] | cdktf.IResolvable) {
    this._lifecycleRule.internalValue = value;
  }
  public resetLifecycleRule() {
    this._lifecycleRule.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lifecycleRuleInput() {
    return this._lifecycleRule.internalValue;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      lifecycle_rule: cdktf.listMapper(deeplyNestedBlockTypesLifecycleRuleToTerraform, true)(this._lifecycleRule.internalValue),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      lifecycle_rule: {
        value: cdktf.listMapperHcl(deeplyNestedBlockTypesLifecycleRuleToHclTerraform, true)(this._lifecycleRule.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "DeeplyNestedBlockTypesLifecycleRuleList",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`ignored attributes 1`] = `
"// https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/ignored_attributes
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface IgnoredAttributesConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/ignored_attributes#id IgnoredAttributes#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/ignored_attributes aws_ignored_attributes}
*/
export class IgnoredAttributes extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aws_ignored_attributes";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a IgnoredAttributes resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the IgnoredAttributes to import
  * @param importFromId The id of the existing IgnoredAttributes that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/ignored_attributes#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the IgnoredAttributes to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aws_ignored_attributes", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/ignored_attributes aws_ignored_attributes} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options IgnoredAttributesConfig = {}
  */
  public constructor(scope: Construct, id: string, config: IgnoredAttributesConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_ignored_attributes',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._id = config.id;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // arn - computed: true, optional: false, required: false
  public get arn() {
    return this.getStringAttribute('arn');
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      id: cdktf.stringToTerraform(this._id),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      id: {
        value: cdktf.stringToHclTerraform(this._id),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`incompatible attribute names 1`] = `
"// https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/incompatible_attribute_names
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface IncompatibleAttributeNamesConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/incompatible_attribute_names#get_password_data IncompatibleAttributeNames#get_password_data}
  */
  readonly fetchPasswordData?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/incompatible_attribute_names#self IncompatibleAttributeNames#self}
  */
  readonly selfAttribute: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/incompatible_attribute_names#equals IncompatibleAttributeNames#equals}
  */
  readonly equalTo: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/incompatible_attribute_names#node IncompatibleAttributeNames#node}
  */
  readonly nodeAttribute: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/incompatible_attribute_names#system IncompatibleAttributeNames#system}
  */
  readonly systemAttribute: string;
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/incompatible_attribute_names aws_incompatible_attribute_names}
*/
export class IncompatibleAttributeNames extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aws_incompatible_attribute_names";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a IncompatibleAttributeNames resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the IncompatibleAttributeNames to import
  * @param importFromId The id of the existing IncompatibleAttributeNames that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/incompatible_attribute_names#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the IncompatibleAttributeNames to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aws_incompatible_attribute_names", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/incompatible_attribute_names aws_incompatible_attribute_names} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options IncompatibleAttributeNamesConfig
  */
  public constructor(scope: Construct, id: string, config: IncompatibleAttributeNamesConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_incompatible_attribute_names',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._getPasswordData = config.fetchPasswordData;
    this._self = config.selfAttribute;
    this._equals = config.equalTo;
    this._node = config.nodeAttribute;
    this._system = config.systemAttribute;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // get_password_data - computed: false, optional: true, required: false
  private _getPasswordData?: string; 
  public get fetchPasswordData() {
    return this.getStringAttribute('get_password_data');
  }
  public set fetchPasswordData(value: string) {
    this._getPasswordData = value;
  }
  public resetFetchPasswordData() {
    this._getPasswordData = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fetchPasswordDataInput() {
    return this._getPasswordData;
  }

  // self - computed: false, optional: false, required: true
  private _self?: string; 
  public get selfAttribute() {
    return this.getStringAttribute('self');
  }
  public set selfAttribute(value: string) {
    this._self = value;
  }
  // Temporarily expose input value. Use with caution.
  public get selfAttributeInput() {
    return this._self;
  }

  // equals - computed: false, optional: false, required: true
  private _equals?: string; 
  public get equalTo() {
    return this.getStringAttribute('equals');
  }
  public set equalTo(value: string) {
    this._equals = value;
  }
  // Temporarily expose input value. Use with caution.
  public get equalToInput() {
    return this._equals;
  }

  // node - computed: false, optional: false, required: true
  private _node?: string; 
  public get nodeAttribute() {
    return this.getStringAttribute('node');
  }
  public set nodeAttribute(value: string) {
    this._node = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeAttributeInput() {
    return this._node;
  }

  // system - computed: false, optional: false, required: true
  private _system?: string; 
  public get systemAttribute() {
    return this.getStringAttribute('system');
  }
  public set systemAttribute(value: string) {
    this._system = value;
  }
  // Temporarily expose input value. Use with caution.
  public get systemAttributeInput() {
    return this._system;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      get_password_data: cdktf.stringToTerraform(this._getPasswordData),
      self: cdktf.stringToTerraform(this._self),
      equals: cdktf.stringToTerraform(this._equals),
      node: cdktf.stringToTerraform(this._node),
      system: cdktf.stringToTerraform(this._system),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      get_password_data: {
        value: cdktf.stringToHclTerraform(this._getPasswordData),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      self: {
        value: cdktf.stringToHclTerraform(this._self),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      equals: {
        value: cdktf.stringToHclTerraform(this._equals),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      node: {
        value: cdktf.stringToHclTerraform(this._node),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      system: {
        value: cdktf.stringToHclTerraform(this._system),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`incompatible resource names: function-resource 1`] = `
"// https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/function
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface FunctionResourceConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/function#dummy FunctionResource#dummy}
  */
  readonly dummy?: string;
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/function test_function}
*/
export class FunctionResource extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "test_function";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a FunctionResource resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the FunctionResource to import
  * @param importFromId The id of the existing FunctionResource that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/function#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the FunctionResource to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "test_function", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/function test_function} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options FunctionResourceConfig = {}
  */
  public constructor(scope: Construct, id: string, config: FunctionResourceConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'test_function',
      terraformGeneratorMetadata: {
        providerName: 'test'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._dummy = config.dummy;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // dummy - computed: false, optional: true, required: false
  private _dummy?: string; 
  public get dummy() {
    return this.getStringAttribute('dummy');
  }
  public set dummy(value: string) {
    this._dummy = value;
  }
  public resetDummy() {
    this._dummy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dummyInput() {
    return this._dummy;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      dummy: cdktf.stringToTerraform(this._dummy),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      dummy: {
        value: cdktf.stringToHclTerraform(this._dummy),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`incompatible resource names: index.ts 1`] = `
"// generated by cdktf get
export * as stringResource from './string-resource';
export * as objectResource from './object-resource';
export * as functionResource from './function-resource';
export * as staticResource from './static-resource';
export * as providerResource from './provider-resource';
export * as licenseResource from './license-resource';

"
`;

exports[`incompatible resource names: lazy-index.ts 1`] = `
"// generated by cdktf get
Object.defineProperty(exports, 'stringResource', { get: function () { return require('./string-resource'); } });
Object.defineProperty(exports, 'objectResource', { get: function () { return require('./object-resource'); } });
Object.defineProperty(exports, 'functionResource', { get: function () { return require('./function-resource'); } });
Object.defineProperty(exports, 'staticResource', { get: function () { return require('./static-resource'); } });
Object.defineProperty(exports, 'providerResource', { get: function () { return require('./provider-resource'); } });
Object.defineProperty(exports, 'licenseResource', { get: function () { return require('./license-resource'); } });

"
`;

exports[`incompatible resource names: license-resource 1`] = `
"// https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/license
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface LicenseResourceConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/license#dummy LicenseResource#dummy}
  */
  readonly dummy?: string;
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/license test_license}
*/
export class LicenseResource extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "test_license";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a LicenseResource resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the LicenseResource to import
  * @param importFromId The id of the existing LicenseResource that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/license#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the LicenseResource to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "test_license", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/license test_license} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options LicenseResourceConfig = {}
  */
  public constructor(scope: Construct, id: string, config: LicenseResourceConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'test_license',
      terraformGeneratorMetadata: {
        providerName: 'test'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._dummy = config.dummy;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // dummy - computed: false, optional: true, required: false
  private _dummy?: string; 
  public get dummy() {
    return this.getStringAttribute('dummy');
  }
  public set dummy(value: string) {
    this._dummy = value;
  }
  public resetDummy() {
    this._dummy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dummyInput() {
    return this._dummy;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      dummy: cdktf.stringToTerraform(this._dummy),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      dummy: {
        value: cdktf.stringToHclTerraform(this._dummy),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`incompatible resource names: object-resource 1`] = `
"// https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/object
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface ObjectResourceConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/object#dummy ObjectResource#dummy}
  */
  readonly dummy?: string;
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/object test_object}
*/
export class ObjectResource extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "test_object";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a ObjectResource resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the ObjectResource to import
  * @param importFromId The id of the existing ObjectResource that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/object#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the ObjectResource to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "test_object", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/object test_object} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options ObjectResourceConfig = {}
  */
  public constructor(scope: Construct, id: string, config: ObjectResourceConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'test_object',
      terraformGeneratorMetadata: {
        providerName: 'test'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._dummy = config.dummy;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // dummy - computed: false, optional: true, required: false
  private _dummy?: string; 
  public get dummy() {
    return this.getStringAttribute('dummy');
  }
  public set dummy(value: string) {
    this._dummy = value;
  }
  public resetDummy() {
    this._dummy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dummyInput() {
    return this._dummy;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      dummy: cdktf.stringToTerraform(this._dummy),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      dummy: {
        value: cdktf.stringToHclTerraform(this._dummy),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`incompatible resource names: provider-resource 1`] = `
"// https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/provider
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface ProviderResourceConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/provider#dummy ProviderResource#dummy}
  */
  readonly dummy?: string;
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/provider test_provider}
*/
export class ProviderResource extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "test_provider";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a ProviderResource resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the ProviderResource to import
  * @param importFromId The id of the existing ProviderResource that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/provider#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the ProviderResource to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "test_provider", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/provider test_provider} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options ProviderResourceConfig = {}
  */
  public constructor(scope: Construct, id: string, config: ProviderResourceConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'test_provider',
      terraformGeneratorMetadata: {
        providerName: 'test'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._dummy = config.dummy;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // dummy - computed: false, optional: true, required: false
  private _dummy?: string; 
  public get dummy() {
    return this.getStringAttribute('dummy');
  }
  public set dummy(value: string) {
    this._dummy = value;
  }
  public resetDummy() {
    this._dummy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dummyInput() {
    return this._dummy;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      dummy: cdktf.stringToTerraform(this._dummy),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      dummy: {
        value: cdktf.stringToHclTerraform(this._dummy),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`incompatible resource names: static-resource 1`] = `
"// https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/static
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface StaticResourceConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/static#dummy StaticResource#dummy}
  */
  readonly dummy?: string;
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/static test_static}
*/
export class StaticResource extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "test_static";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a StaticResource resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the StaticResource to import
  * @param importFromId The id of the existing StaticResource that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/static#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the StaticResource to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "test_static", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/static test_static} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options StaticResourceConfig = {}
  */
  public constructor(scope: Construct, id: string, config: StaticResourceConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'test_static',
      terraformGeneratorMetadata: {
        providerName: 'test'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._dummy = config.dummy;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // dummy - computed: false, optional: true, required: false
  private _dummy?: string; 
  public get dummy() {
    return this.getStringAttribute('dummy');
  }
  public set dummy(value: string) {
    this._dummy = value;
  }
  public resetDummy() {
    this._dummy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dummyInput() {
    return this._dummy;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      dummy: cdktf.stringToTerraform(this._dummy),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      dummy: {
        value: cdktf.stringToHclTerraform(this._dummy),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`incompatible resource names: string-resource 1`] = `
"// https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/string
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface StringResourceConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/string#dummy StringResource#dummy}
  */
  readonly dummy?: string;
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/string test_string}
*/
export class StringResource extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "test_string";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a StringResource resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the StringResource to import
  * @param importFromId The id of the existing StringResource that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/string#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the StringResource to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "test_string", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/string test_string} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options StringResourceConfig = {}
  */
  public constructor(scope: Construct, id: string, config: StringResourceConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'test_string',
      terraformGeneratorMetadata: {
        providerName: 'test'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._dummy = config.dummy;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // dummy - computed: false, optional: true, required: false
  private _dummy?: string; 
  public get dummy() {
    return this.getStringAttribute('dummy');
  }
  public set dummy(value: string) {
    this._dummy = value;
  }
  public resetDummy() {
    this._dummy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dummyInput() {
    return this._dummy;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      dummy: cdktf.stringToTerraform(this._dummy),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      dummy: {
        value: cdktf.stringToHclTerraform(this._dummy),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`list of list attributes 1`] = `
"// https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/complex
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface ComplexConfig extends cdktf.TerraformMetaArguments {
}
export interface ComplexLl {
}

export function complexLlToTerraform(struct?: ComplexLl): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function complexLlToHclTerraform(struct?: ComplexLl): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class ComplexLlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ComplexLl | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ComplexLl | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // coupon - computed: true, optional: false, required: false
  public get coupon() {
    return this.getStringAttribute('coupon');
  }

  // discount_amount - computed: true, optional: false, required: false
  public get discountAmount() {
    return this.getStringAttribute('discount_amount');
  }
}

export class ComplexLlListList extends cdktf.MapList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ComplexLlList {
    return new ComplexLlList(this, \`[\${index}]\`, false);
  }
}

export class ComplexLlList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ComplexLlOutputReference {
    return new ComplexLlOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ComplexLs {
}

export function complexLsToTerraform(struct?: ComplexLs): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function complexLsToHclTerraform(struct?: ComplexLs): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class ComplexLsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ComplexLs | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ComplexLs | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // coupon - computed: true, optional: false, required: false
  public get coupon() {
    return this.getStringAttribute('coupon');
  }

  // discount_amount - computed: true, optional: false, required: false
  public get discountAmount() {
    return this.getStringAttribute('discount_amount');
  }
}

export class ComplexLsListList extends cdktf.MapList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ComplexLsList {
    return new ComplexLsList(this, \`[\${index}]\`, true);
  }
}

export class ComplexLsList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ComplexLsOutputReference {
    return new ComplexLsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ComplexSl {
}

export function complexSlToTerraform(struct?: ComplexSl): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function complexSlToHclTerraform(struct?: ComplexSl): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class ComplexSlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ComplexSl | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ComplexSl | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // coupon - computed: true, optional: false, required: false
  public get coupon() {
    return this.getStringAttribute('coupon');
  }

  // discount_amount - computed: true, optional: false, required: false
  public get discountAmount() {
    return this.getStringAttribute('discount_amount');
  }
}

export class ComplexSlListList extends cdktf.MapList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ComplexSlList {
    return new ComplexSlList(this, \`[\${index}]\`, false);
  }
}

export class ComplexSlList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ComplexSlOutputReference {
    return new ComplexSlOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ComplexSs {
}

export function complexSsToTerraform(struct?: ComplexSs): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function complexSsToHclTerraform(struct?: ComplexSs): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class ComplexSsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ComplexSs | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ComplexSs | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // coupon - computed: true, optional: false, required: false
  public get coupon() {
    return this.getStringAttribute('coupon');
  }

  // discount_amount - computed: true, optional: false, required: false
  public get discountAmount() {
    return this.getStringAttribute('discount_amount');
  }
}

export class ComplexSsListList extends cdktf.MapList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ComplexSsList {
    return new ComplexSsList(this, \`[\${index}]\`, true);
  }
}

export class ComplexSsList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ComplexSsOutputReference {
    return new ComplexSsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/complex test_complex}
*/
export class Complex extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "test_complex";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a Complex resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the Complex to import
  * @param importFromId The id of the existing Complex that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/complex#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the Complex to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "test_complex", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/resources/complex test_complex} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options ComplexConfig = {}
  */
  public constructor(scope: Construct, id: string, config: ComplexConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'test_complex',
      terraformGeneratorMetadata: {
        providerName: 'test'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // ll - computed: true, optional: false, required: false
  private _ll = new ComplexLlListList(this, "ll", false);
  public get ll() {
    return this._ll;
  }

  // ls - computed: true, optional: false, required: false
  private _ls = new ComplexLsListList(this, "ls", false);
  public get ls() {
    return this._ls;
  }

  // sl - computed: true, optional: false, required: false
  private _sl = new ComplexSlListList(this, "sl", true);
  public get sl() {
    return this._sl;
  }

  // ss - computed: true, optional: false, required: false
  private _ss = new ComplexSsListList(this, "ss", true);
  public get ss() {
    return this._ss;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
    };
    return attrs;
  }
}
"
`;

exports[`list of list of strings 1`] = `
"// https://registry.terraform.io/providers/hashicorp/test/latest/docs/data-sources/airbyte_source_schema_catalog
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface DataAirbyteSourceSchemaCatalogConfig extends cdktf.TerraformMetaArguments {
  /**
  * Non-computed list of list of string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/data-sources/airbyte_source_schema_catalog#non_computed_list_list_string DataAirbyteSourceSchemaCatalog#non_computed_list_list_string}
  */
  readonly nonComputedListListString?: string[][] | cdktf.IResolvable;
}
export interface DataAirbyteSourceSchemaCatalogSyncCatalogSourceSchema {
}

export function dataAirbyteSourceSchemaCatalogSyncCatalogSourceSchemaToTerraform(struct?: DataAirbyteSourceSchemaCatalogSyncCatalogSourceSchema): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAirbyteSourceSchemaCatalogSyncCatalogSourceSchemaToHclTerraform(struct?: DataAirbyteSourceSchemaCatalogSyncCatalogSourceSchema): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAirbyteSourceSchemaCatalogSyncCatalogSourceSchemaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataAirbyteSourceSchemaCatalogSyncCatalogSourceSchema | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAirbyteSourceSchemaCatalogSyncCatalogSourceSchema | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // source_defined_primary_key - computed: true, optional: false, required: false
  private _sourceDefinedPrimaryKey = new cdktf.StringListList(this, "source_defined_primary_key", false);
  public get sourceDefinedPrimaryKey() {
    return this._sourceDefinedPrimaryKey;
  }
}
export interface DataAirbyteSourceSchemaCatalogSyncCatalog {
}

export function dataAirbyteSourceSchemaCatalogSyncCatalogToTerraform(struct?: DataAirbyteSourceSchemaCatalogSyncCatalog): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAirbyteSourceSchemaCatalogSyncCatalogToHclTerraform(struct?: DataAirbyteSourceSchemaCatalogSyncCatalog): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAirbyteSourceSchemaCatalogSyncCatalogOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAirbyteSourceSchemaCatalogSyncCatalog | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAirbyteSourceSchemaCatalogSyncCatalog | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // source_schema - computed: true, optional: false, required: false
  private _sourceSchema = new DataAirbyteSourceSchemaCatalogSyncCatalogSourceSchemaOutputReference(this, "source_schema");
  public get sourceSchema() {
    return this._sourceSchema;
  }
}

export class DataAirbyteSourceSchemaCatalogSyncCatalogList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAirbyteSourceSchemaCatalogSyncCatalogOutputReference {
    return new DataAirbyteSourceSchemaCatalogSyncCatalogOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/data-sources/airbyte_source_schema_catalog airbyte_source_schema_catalog}
*/
export class DataAirbyteSourceSchemaCatalog extends cdktf.TerraformDataSource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "airbyte_source_schema_catalog";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a DataAirbyteSourceSchemaCatalog resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the DataAirbyteSourceSchemaCatalog to import
  * @param importFromId The id of the existing DataAirbyteSourceSchemaCatalog that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/data-sources/airbyte_source_schema_catalog#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the DataAirbyteSourceSchemaCatalog to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "airbyte_source_schema_catalog", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/test/latest/docs/data-sources/airbyte_source_schema_catalog airbyte_source_schema_catalog} Data Source
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options DataAirbyteSourceSchemaCatalogConfig = {}
  */
  public constructor(scope: Construct, id: string, config: DataAirbyteSourceSchemaCatalogConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'airbyte_source_schema_catalog',
      terraformGeneratorMetadata: {
        providerName: 'test'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._nonComputedListListString = config.nonComputedListListString;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // sync_catalog - computed: true, optional: false, required: false
  private _syncCatalog = new DataAirbyteSourceSchemaCatalogSyncCatalogList(this, "sync_catalog", false);
  public get syncCatalog() {
    return this._syncCatalog;
  }

  // non_computed_list_list_string - computed: false, optional: true, required: false
  private _nonComputedListListString?: string[][] | cdktf.IResolvable; 
  public get nonComputedListListString() {
    return this.interpolationForAttribute('non_computed_list_list_string');
  }
  public set nonComputedListListString(value: string[][] | cdktf.IResolvable) {
    this._nonComputedListListString = value;
  }
  public resetNonComputedListListString() {
    this._nonComputedListListString = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nonComputedListListStringInput() {
    return this._nonComputedListListString;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      non_computed_list_list_string: cdktf.listMapper(cdktf.listMapper(cdktf.stringToTerraform, false), false)(this._nonComputedListListString),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      non_computed_list_list_string: {
        value: cdktf.listMapperHcl(cdktf.listMapperHcl(cdktf.stringToHclTerraform, false), false)(this._nonComputedListListString),
        isBlock: false,
        type: "list",
        storageClassType: "stringListList",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`list of string map attribute 1`] = `
"// https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/list_of_string_map
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface ListOfStringMapConfig extends cdktf.TerraformMetaArguments {
  /**
  * List of key versions in the keyring.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/list_of_string_map#settable_keys ListOfStringMap#settable_keys}
  */
  readonly settableKeys?: { [key: string]: string }[] | cdktf.IResolvable;
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/list_of_string_map aws_list_of_string_map}
*/
export class ListOfStringMap extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aws_list_of_string_map";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a ListOfStringMap resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the ListOfStringMap to import
  * @param importFromId The id of the existing ListOfStringMap that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/list_of_string_map#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the ListOfStringMap to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aws_list_of_string_map", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/list_of_string_map aws_list_of_string_map} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options ListOfStringMapConfig = {}
  */
  public constructor(scope: Construct, id: string, config: ListOfStringMapConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_list_of_string_map',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._settableKeys = config.settableKeys;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // keys - computed: true, optional: false, required: false
  private _keys = new cdktf.StringMapList(this, "keys", false);
  public get keys() {
    return this._keys;
  }

  // settable_keys - computed: false, optional: true, required: false
  private _settableKeys?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get settableKeys() {
    return this.interpolationForAttribute('settable_keys');
  }
  public set settableKeys(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._settableKeys = value;
  }
  public resetSettableKeys() {
    this._settableKeys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get settableKeysInput() {
    return this._settableKeys;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      settable_keys: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(this._settableKeys),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      settable_keys: {
        value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(this._settableKeys),
        isBlock: false,
        type: "list",
        storageClassType: "stringMapList",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`map of string list attribute 1`] = `
"// https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/map_of_string_list
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface MapOfStringListConfig extends cdktf.TerraformMetaArguments {
  /**
  * Map of String List.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/map_of_string_list#settable_keys MapOfStringList#settable_keys}
  */
  readonly settableKeys?: { [key: string]: string[] } | cdktf.IResolvable;
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/map_of_string_list aws_map_of_string_list}
*/
export class MapOfStringList extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aws_map_of_string_list";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a MapOfStringList resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the MapOfStringList to import
  * @param importFromId The id of the existing MapOfStringList that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/map_of_string_list#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the MapOfStringList to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aws_map_of_string_list", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/map_of_string_list aws_map_of_string_list} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options MapOfStringListConfig = {}
  */
  public constructor(scope: Construct, id: string, config: MapOfStringListConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_map_of_string_list',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._settableKeys = config.settableKeys;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // keys - computed: true, optional: false, required: false
  private _keys = new cdktf.StringListMap(this, "keys");
  public get keys() {
    return this._keys;
  }

  // settable_keys - computed: false, optional: true, required: false
  private _settableKeys?: { [key: string]: string[] } | cdktf.IResolvable; 
  public get settableKeys() {
    return this.interpolationForAttribute('settable_keys');
  }
  public set settableKeys(value: { [key: string]: string[] } | cdktf.IResolvable) {
    this._settableKeys = value;
  }
  public resetSettableKeys() {
    this._settableKeys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get settableKeysInput() {
    return this._settableKeys;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      settable_keys: cdktf.hashMapper(cdktf.listMapper(cdktf.stringToTerraform, false))(this._settableKeys),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      settable_keys: {
        value: cdktf.hashMapperHcl(cdktf.listMapperHcl(cdktf.stringToHclTerraform, false))(this._settableKeys),
        isBlock: false,
        type: "map",
        storageClassType: "stringListMap",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`number list attribute 1`] = `
"// https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/number_list
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface NumberListConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/number_list#foo_required NumberList#foo_required}
  */
  readonly fooRequired: number[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/number_list#foo_optional NumberList#foo_optional}
  */
  readonly fooOptional?: number[];
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/number_list aws_number_list}
*/
export class NumberList extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aws_number_list";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a NumberList resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the NumberList to import
  * @param importFromId The id of the existing NumberList that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/number_list#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the NumberList to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aws_number_list", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/number_list aws_number_list} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options NumberListConfig
  */
  public constructor(scope: Construct, id: string, config: NumberListConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_number_list',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._fooRequired = config.fooRequired;
    this._fooOptional = config.fooOptional;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_required - computed: false, optional: false, required: true
  private _fooRequired?: number[]; 
  public get fooRequired() {
    return this.getNumberListAttribute('foo_required');
  }
  public set fooRequired(value: number[]) {
    this._fooRequired = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fooRequiredInput() {
    return this._fooRequired;
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional?: number[]; 
  public get fooOptional() {
    return this.getNumberListAttribute('foo_optional');
  }
  public set fooOptional(value: number[]) {
    this._fooOptional = value;
  }
  public resetFooOptional() {
    this._fooOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooOptionalInput() {
    return this._fooOptional;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_required: cdktf.listMapper(cdktf.numberToTerraform, false)(this._fooRequired),
      foo_optional: cdktf.listMapper(cdktf.numberToTerraform, false)(this._fooOptional),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      foo_required: {
        value: cdktf.listMapperHcl(cdktf.numberToHclTerraform, false)(this._fooRequired),
        isBlock: false,
        type: "list",
        storageClassType: "numberList",
      },
      foo_optional: {
        value: cdktf.listMapperHcl(cdktf.numberToHclTerraform, false)(this._fooOptional),
        isBlock: false,
        type: "list",
        storageClassType: "numberList",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`number map attribute 1`] = `
"// https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/number_map
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface NumberMapConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/number_map#foo_computed_optional NumberMap#foo_computed_optional}
  */
  readonly fooComputedOptional?: { [key: string]: number };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/number_map#foo_optional NumberMap#foo_optional}
  */
  readonly fooOptional?: { [key: string]: number };
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/number_map aws_number_map}
*/
export class NumberMap extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aws_number_map";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a NumberMap resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the NumberMap to import
  * @param importFromId The id of the existing NumberMap that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/number_map#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the NumberMap to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aws_number_map", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/number_map aws_number_map} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options NumberMapConfig = {}
  */
  public constructor(scope: Construct, id: string, config: NumberMapConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_number_map',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._fooComputedOptional = config.fooComputedOptional;
    this._fooOptional = config.fooOptional;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_computed - computed: true, optional: false, required: false
  private _fooComputed = new cdktf.NumberMap(this, "foo_computed");
  public get fooComputed() {
    return this._fooComputed;
  }

  // foo_computed_optional - computed: true, optional: true, required: false
  private _fooComputedOptional?: { [key: string]: number }; 
  public get fooComputedOptional() {
    return this.getNumberMapAttribute('foo_computed_optional');
  }
  public set fooComputedOptional(value: { [key: string]: number }) {
    this._fooComputedOptional = value;
  }
  public resetFooComputedOptional() {
    this._fooComputedOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooComputedOptionalInput() {
    return this._fooComputedOptional;
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional?: { [key: string]: number }; 
  public get fooOptional() {
    return this.getNumberMapAttribute('foo_optional');
  }
  public set fooOptional(value: { [key: string]: number }) {
    this._fooOptional = value;
  }
  public resetFooOptional() {
    this._fooOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooOptionalInput() {
    return this._fooOptional;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_computed_optional: cdktf.hashMapper(cdktf.numberToTerraform)(this._fooComputedOptional),
      foo_optional: cdktf.hashMapper(cdktf.numberToTerraform)(this._fooOptional),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      foo_computed_optional: {
        value: cdktf.hashMapperHcl(cdktf.numberToHclTerraform)(this._fooComputedOptional),
        isBlock: false,
        type: "map",
        storageClassType: "numberMap",
      },
      foo_optional: {
        value: cdktf.hashMapperHcl(cdktf.numberToHclTerraform)(this._fooOptional),
        isBlock: false,
        type: "map",
        storageClassType: "numberMap",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`primitive boolean 1`] = `
"// https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_boolean
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface PrimitiveBooleanConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_boolean#foo_computed_optional PrimitiveBoolean#foo_computed_optional}
  */
  readonly fooComputedOptional?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_boolean#foo_optional PrimitiveBoolean#foo_optional}
  */
  readonly fooOptional?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_boolean#foo_required PrimitiveBoolean#foo_required}
  */
  readonly fooRequired: boolean | cdktf.IResolvable;
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_boolean aws_primitive_boolean}
*/
export class PrimitiveBoolean extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aws_primitive_boolean";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a PrimitiveBoolean resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the PrimitiveBoolean to import
  * @param importFromId The id of the existing PrimitiveBoolean that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_boolean#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the PrimitiveBoolean to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aws_primitive_boolean", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_boolean aws_primitive_boolean} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options PrimitiveBooleanConfig
  */
  public constructor(scope: Construct, id: string, config: PrimitiveBooleanConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_primitive_boolean',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._fooComputedOptional = config.fooComputedOptional;
    this._fooOptional = config.fooOptional;
    this._fooRequired = config.fooRequired;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_computed - computed: true, optional: false, required: false
  public get fooComputed() {
    return this.getBooleanAttribute('foo_computed');
  }

  // foo_computed_optional - computed: true, optional: true, required: false
  private _fooComputedOptional?: boolean | cdktf.IResolvable; 
  public get fooComputedOptional() {
    return this.getBooleanAttribute('foo_computed_optional');
  }
  public set fooComputedOptional(value: boolean | cdktf.IResolvable) {
    this._fooComputedOptional = value;
  }
  public resetFooComputedOptional() {
    this._fooComputedOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooComputedOptionalInput() {
    return this._fooComputedOptional;
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional?: boolean | cdktf.IResolvable; 
  public get fooOptional() {
    return this.getBooleanAttribute('foo_optional');
  }
  public set fooOptional(value: boolean | cdktf.IResolvable) {
    this._fooOptional = value;
  }
  public resetFooOptional() {
    this._fooOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooOptionalInput() {
    return this._fooOptional;
  }

  // foo_required - computed: false, optional: false, required: true
  private _fooRequired?: boolean | cdktf.IResolvable; 
  public get fooRequired() {
    return this.getBooleanAttribute('foo_required');
  }
  public set fooRequired(value: boolean | cdktf.IResolvable) {
    this._fooRequired = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fooRequiredInput() {
    return this._fooRequired;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_computed_optional: cdktf.booleanToTerraform(this._fooComputedOptional),
      foo_optional: cdktf.booleanToTerraform(this._fooOptional),
      foo_required: cdktf.booleanToTerraform(this._fooRequired),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      foo_computed_optional: {
        value: cdktf.booleanToHclTerraform(this._fooComputedOptional),
        isBlock: false,
        type: "simple",
        storageClassType: "boolean",
      },
      foo_optional: {
        value: cdktf.booleanToHclTerraform(this._fooOptional),
        isBlock: false,
        type: "simple",
        storageClassType: "boolean",
      },
      foo_required: {
        value: cdktf.booleanToHclTerraform(this._fooRequired),
        isBlock: false,
        type: "simple",
        storageClassType: "boolean",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`primitive dynamic 1`] = `
"// https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_dynamic
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface PrimitiveDynamicConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_dynamic#foo_computed_optional PrimitiveDynamic#foo_computed_optional}
  */
  readonly fooComputedOptional?: { [key: string]: any };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_dynamic#foo_optional PrimitiveDynamic#foo_optional}
  */
  readonly fooOptional?: { [key: string]: any };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_dynamic#foo_required PrimitiveDynamic#foo_required}
  */
  readonly fooRequired: { [key: string]: any };
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_dynamic aws_primitive_dynamic}
*/
export class PrimitiveDynamic extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aws_primitive_dynamic";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a PrimitiveDynamic resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the PrimitiveDynamic to import
  * @param importFromId The id of the existing PrimitiveDynamic that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_dynamic#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the PrimitiveDynamic to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aws_primitive_dynamic", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_dynamic aws_primitive_dynamic} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options PrimitiveDynamicConfig
  */
  public constructor(scope: Construct, id: string, config: PrimitiveDynamicConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_primitive_dynamic',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._fooComputedOptional = config.fooComputedOptional;
    this._fooOptional = config.fooOptional;
    this._fooRequired = config.fooRequired;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_computed - computed: true, optional: false, required: false
  private _fooComputed = new cdktf.AnyMap(this, "foo_computed");
  public get fooComputed() {
    return this._fooComputed;
  }

  // foo_computed_optional - computed: true, optional: true, required: false
  private _fooComputedOptional?: { [key: string]: any }; 
  public get fooComputedOptional() {
    return this.getAnyMapAttribute('foo_computed_optional');
  }
  public set fooComputedOptional(value: { [key: string]: any }) {
    this._fooComputedOptional = value;
  }
  public resetFooComputedOptional() {
    this._fooComputedOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooComputedOptionalInput() {
    return this._fooComputedOptional;
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional?: { [key: string]: any }; 
  public get fooOptional() {
    return this.getAnyMapAttribute('foo_optional');
  }
  public set fooOptional(value: { [key: string]: any }) {
    this._fooOptional = value;
  }
  public resetFooOptional() {
    this._fooOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooOptionalInput() {
    return this._fooOptional;
  }

  // foo_required - computed: false, optional: false, required: true
  private _fooRequired?: { [key: string]: any }; 
  public get fooRequired() {
    return this.getAnyMapAttribute('foo_required');
  }
  public set fooRequired(value: { [key: string]: any }) {
    this._fooRequired = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fooRequiredInput() {
    return this._fooRequired;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_computed_optional: cdktf.hashMapper(cdktf.anyToTerraform)(this._fooComputedOptional),
      foo_optional: cdktf.hashMapper(cdktf.anyToTerraform)(this._fooOptional),
      foo_required: cdktf.hashMapper(cdktf.anyToTerraform)(this._fooRequired),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      foo_computed_optional: {
        value: cdktf.hashMapperHcl(cdktf.anyToHclTerraform)(this._fooComputedOptional),
        isBlock: false,
        type: "map",
        storageClassType: "anyMap",
      },
      foo_optional: {
        value: cdktf.hashMapperHcl(cdktf.anyToHclTerraform)(this._fooOptional),
        isBlock: false,
        type: "map",
        storageClassType: "anyMap",
      },
      foo_required: {
        value: cdktf.hashMapperHcl(cdktf.anyToHclTerraform)(this._fooRequired),
        isBlock: false,
        type: "map",
        storageClassType: "anyMap",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`primitive number 1`] = `
"// https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_number
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface PrimitiveNumberConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_number#foo_computed_optional PrimitiveNumber#foo_computed_optional}
  */
  readonly fooComputedOptional?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_number#foo_optional PrimitiveNumber#foo_optional}
  */
  readonly fooOptional?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_number#foo_required PrimitiveNumber#foo_required}
  */
  readonly fooRequired: number;
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_number aws_primitive_number}
*/
export class PrimitiveNumber extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aws_primitive_number";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a PrimitiveNumber resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the PrimitiveNumber to import
  * @param importFromId The id of the existing PrimitiveNumber that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_number#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the PrimitiveNumber to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aws_primitive_number", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_number aws_primitive_number} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options PrimitiveNumberConfig
  */
  public constructor(scope: Construct, id: string, config: PrimitiveNumberConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_primitive_number',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._fooComputedOptional = config.fooComputedOptional;
    this._fooOptional = config.fooOptional;
    this._fooRequired = config.fooRequired;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_computed - computed: true, optional: false, required: false
  public get fooComputed() {
    return this.getNumberAttribute('foo_computed');
  }

  // foo_computed_optional - computed: true, optional: true, required: false
  private _fooComputedOptional?: number; 
  public get fooComputedOptional() {
    return this.getNumberAttribute('foo_computed_optional');
  }
  public set fooComputedOptional(value: number) {
    this._fooComputedOptional = value;
  }
  public resetFooComputedOptional() {
    this._fooComputedOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooComputedOptionalInput() {
    return this._fooComputedOptional;
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional?: number; 
  public get fooOptional() {
    return this.getNumberAttribute('foo_optional');
  }
  public set fooOptional(value: number) {
    this._fooOptional = value;
  }
  public resetFooOptional() {
    this._fooOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooOptionalInput() {
    return this._fooOptional;
  }

  // foo_required - computed: false, optional: false, required: true
  private _fooRequired?: number; 
  public get fooRequired() {
    return this.getNumberAttribute('foo_required');
  }
  public set fooRequired(value: number) {
    this._fooRequired = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fooRequiredInput() {
    return this._fooRequired;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_computed_optional: cdktf.numberToTerraform(this._fooComputedOptional),
      foo_optional: cdktf.numberToTerraform(this._fooOptional),
      foo_required: cdktf.numberToTerraform(this._fooRequired),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      foo_computed_optional: {
        value: cdktf.numberToHclTerraform(this._fooComputedOptional),
        isBlock: false,
        type: "simple",
        storageClassType: "number",
      },
      foo_optional: {
        value: cdktf.numberToHclTerraform(this._fooOptional),
        isBlock: false,
        type: "simple",
        storageClassType: "number",
      },
      foo_required: {
        value: cdktf.numberToHclTerraform(this._fooRequired),
        isBlock: false,
        type: "simple",
        storageClassType: "number",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`primitive string 1`] = `
"// https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_string
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface PrimitiveStringConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_string#foo_computed_optional PrimitiveString#foo_computed_optional}
  */
  readonly fooComputedOptional?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_string#foo_optional PrimitiveString#foo_optional}
  */
  readonly fooOptional?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_string#foo_required PrimitiveString#foo_required}
  */
  readonly fooRequired: string;
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_string aws_primitive_string}
*/
export class PrimitiveString extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aws_primitive_string";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a PrimitiveString resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the PrimitiveString to import
  * @param importFromId The id of the existing PrimitiveString that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_string#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the PrimitiveString to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aws_primitive_string", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/primitive_string aws_primitive_string} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options PrimitiveStringConfig
  */
  public constructor(scope: Construct, id: string, config: PrimitiveStringConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_primitive_string',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._fooComputedOptional = config.fooComputedOptional;
    this._fooOptional = config.fooOptional;
    this._fooRequired = config.fooRequired;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_computed - computed: true, optional: false, required: false
  public get fooComputed() {
    return this.getStringAttribute('foo_computed');
  }

  // foo_computed_optional - computed: true, optional: true, required: false
  private _fooComputedOptional?: string; 
  public get fooComputedOptional() {
    return this.getStringAttribute('foo_computed_optional');
  }
  public set fooComputedOptional(value: string) {
    this._fooComputedOptional = value;
  }
  public resetFooComputedOptional() {
    this._fooComputedOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooComputedOptionalInput() {
    return this._fooComputedOptional;
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional?: string; 
  public get fooOptional() {
    return this.getStringAttribute('foo_optional');
  }
  public set fooOptional(value: string) {
    this._fooOptional = value;
  }
  public resetFooOptional() {
    this._fooOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooOptionalInput() {
    return this._fooOptional;
  }

  // foo_required - computed: false, optional: false, required: true
  private _fooRequired?: string; 
  public get fooRequired() {
    return this.getStringAttribute('foo_required');
  }
  public set fooRequired(value: string) {
    this._fooRequired = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fooRequiredInput() {
    return this._fooRequired;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_computed_optional: cdktf.stringToTerraform(this._fooComputedOptional),
      foo_optional: cdktf.stringToTerraform(this._fooOptional),
      foo_required: cdktf.stringToTerraform(this._fooRequired),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      foo_computed_optional: {
        value: cdktf.stringToHclTerraform(this._fooComputedOptional),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      foo_optional: {
        value: cdktf.stringToHclTerraform(this._fooOptional),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      foo_required: {
        value: cdktf.stringToHclTerraform(this._fooRequired),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`reset and input name conflicts 1`] = `
"// https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/name_conflict
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface NameConflictConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/name_conflict#values NameConflict#values}
  */
  readonly values?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/name_conflict#reset_values NameConflict#reset_values}
  */
  readonly resetValues?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/name_conflict#template NameConflict#template}
  */
  readonly template?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/name_conflict#template_input NameConflict#template_input}
  */
  readonly templateInput?: string;
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/name_conflict aws_name_conflict}
*/
export class NameConflict extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aws_name_conflict";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a NameConflict resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the NameConflict to import
  * @param importFromId The id of the existing NameConflict that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/name_conflict#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the NameConflict to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aws_name_conflict", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/name_conflict aws_name_conflict} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options NameConflictConfig = {}
  */
  public constructor(scope: Construct, id: string, config: NameConflictConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_name_conflict',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._values = config.values;
    this._resetValues = config.resetValues;
    this._template = config.template;
    this._templateInput = config.templateInput;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // values - computed: false, optional: true, required: false
  private _values?: string; 
  public get values() {
    return this.getStringAttribute('values');
  }
  public set values(value: string) {
    this._values = value;
  }
  public resetTfValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }

  // reset_values - computed: false, optional: true, required: false
  private _resetValues?: string; 
  public get resetValues() {
    return this.getStringAttribute('reset_values');
  }
  public set resetValues(value: string) {
    this._resetValues = value;
  }
  public resetResetValues() {
    this._resetValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resetValuesInput() {
    return this._resetValues;
  }

  // template - computed: false, optional: true, required: false
  private _template?: string; 
  public get template() {
    return this.getStringAttribute('template');
  }
  public set template(value: string) {
    this._template = value;
  }
  public resetTemplate() {
    this._template = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateTfInput() {
    return this._template;
  }

  // template_input - computed: false, optional: true, required: false
  private _templateInput?: string; 
  public get templateInput() {
    return this.getStringAttribute('template_input');
  }
  public set templateInput(value: string) {
    this._templateInput = value;
  }
  public resetTemplateInput() {
    this._templateInput = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInputInput() {
    return this._templateInput;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      values: cdktf.stringToTerraform(this._values),
      reset_values: cdktf.stringToTerraform(this._resetValues),
      template: cdktf.stringToTerraform(this._template),
      template_input: cdktf.stringToTerraform(this._templateInput),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      values: {
        value: cdktf.stringToHclTerraform(this._values),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      reset_values: {
        value: cdktf.stringToHclTerraform(this._resetValues),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      template: {
        value: cdktf.stringToHclTerraform(this._template),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      template_input: {
        value: cdktf.stringToHclTerraform(this._templateInput),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`set / list block type 1`] = `
"// https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/block_type_set_list
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface BlockTypeSetListConfig extends cdktf.TerraformMetaArguments {
  /**
  * timeouts_set block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/block_type_set_list#timeouts_set BlockTypeSetList#timeouts_set}
  */
  readonly timeoutsSet?: BlockTypeSetListTimeoutsSet[] | cdktf.IResolvable;
  /**
  * timeouts_list block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/block_type_set_list#timeouts_list BlockTypeSetList#timeouts_list}
  */
  readonly timeoutsList?: BlockTypeSetListTimeoutsListStruct[] | cdktf.IResolvable;
}
export interface BlockTypeSetListTimeoutsSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/block_type_set_list#create BlockTypeSetList#create}
  */
  readonly create?: string;
}

export function blockTypeSetListTimeoutsSetToTerraform(struct?: BlockTypeSetListTimeoutsSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    create: cdktf.stringToTerraform(struct!.create),
  }
}


export function blockTypeSetListTimeoutsSetToHclTerraform(struct?: BlockTypeSetListTimeoutsSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    create: {
      value: cdktf.stringToHclTerraform(struct!.create),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class BlockTypeSetListTimeoutsSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): BlockTypeSetListTimeoutsSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._create !== undefined) {
      hasAnyValues = true;
      internalValueResult.create = this._create;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: BlockTypeSetListTimeoutsSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._create = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._create = value.create;
    }
  }

  // create - computed: false, optional: true, required: false
  private _create?: string; 
  public get create() {
    return this.getStringAttribute('create');
  }
  public set create(value: string) {
    this._create = value;
  }
  public resetCreate() {
    this._create = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createInput() {
    return this._create;
  }
}

export class BlockTypeSetListTimeoutsSetList extends cdktf.ComplexList {
  public internalValue? : BlockTypeSetListTimeoutsSet[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): BlockTypeSetListTimeoutsSetOutputReference {
    return new BlockTypeSetListTimeoutsSetOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface BlockTypeSetListTimeoutsListStruct {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/block_type_set_list#create BlockTypeSetList#create}
  */
  readonly create?: string;
}

export function blockTypeSetListTimeoutsListStructToTerraform(struct?: BlockTypeSetListTimeoutsListStruct | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    create: cdktf.stringToTerraform(struct!.create),
  }
}


export function blockTypeSetListTimeoutsListStructToHclTerraform(struct?: BlockTypeSetListTimeoutsListStruct | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    create: {
      value: cdktf.stringToHclTerraform(struct!.create),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class BlockTypeSetListTimeoutsListStructOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): BlockTypeSetListTimeoutsListStruct | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._create !== undefined) {
      hasAnyValues = true;
      internalValueResult.create = this._create;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: BlockTypeSetListTimeoutsListStruct | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._create = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._create = value.create;
    }
  }

  // create - computed: false, optional: true, required: false
  private _create?: string; 
  public get create() {
    return this.getStringAttribute('create');
  }
  public set create(value: string) {
    this._create = value;
  }
  public resetCreate() {
    this._create = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createInput() {
    return this._create;
  }
}

export class BlockTypeSetListTimeoutsListStructList extends cdktf.ComplexList {
  public internalValue? : BlockTypeSetListTimeoutsListStruct[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): BlockTypeSetListTimeoutsListStructOutputReference {
    return new BlockTypeSetListTimeoutsListStructOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/block_type_set_list aws_block_type_set_list}
*/
export class BlockTypeSetList extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aws_block_type_set_list";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a BlockTypeSetList resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the BlockTypeSetList to import
  * @param importFromId The id of the existing BlockTypeSetList that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/block_type_set_list#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the BlockTypeSetList to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aws_block_type_set_list", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/block_type_set_list aws_block_type_set_list} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options BlockTypeSetListConfig = {}
  */
  public constructor(scope: Construct, id: string, config: BlockTypeSetListConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_block_type_set_list',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._timeoutsSet.internalValue = config.timeoutsSet;
    this._timeoutsList.internalValue = config.timeoutsList;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // timeouts_set - computed: false, optional: true, required: false
  private _timeoutsSet = new BlockTypeSetListTimeoutsSetList(this, "timeouts_set", true);
  public get timeoutsSet() {
    return this._timeoutsSet;
  }
  public putTimeoutsSet(value: BlockTypeSetListTimeoutsSet[] | cdktf.IResolvable) {
    this._timeoutsSet.internalValue = value;
  }
  public resetTimeoutsSet() {
    this._timeoutsSet.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutsSetInput() {
    return this._timeoutsSet.internalValue;
  }

  // timeouts_list - computed: false, optional: true, required: false
  private _timeoutsList = new BlockTypeSetListTimeoutsListStructList(this, "timeouts_list", false);
  public get timeoutsList() {
    return this._timeoutsList;
  }
  public putTimeoutsList(value: BlockTypeSetListTimeoutsListStruct[] | cdktf.IResolvable) {
    this._timeoutsList.internalValue = value;
  }
  public resetTimeoutsList() {
    this._timeoutsList.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutsListInput() {
    return this._timeoutsList.internalValue;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      timeouts_set: cdktf.listMapper(blockTypeSetListTimeoutsSetToTerraform, true)(this._timeoutsSet.internalValue),
      timeouts_list: cdktf.listMapper(blockTypeSetListTimeoutsListStructToTerraform, true)(this._timeoutsList.internalValue),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      timeouts_set: {
        value: cdktf.listMapperHcl(blockTypeSetListTimeoutsSetToHclTerraform, true)(this._timeoutsSet.internalValue),
        isBlock: true,
        type: "set",
        storageClassType: "BlockTypeSetListTimeoutsSetList",
      },
      timeouts_list: {
        value: cdktf.listMapperHcl(blockTypeSetListTimeoutsListStructToHclTerraform, true)(this._timeoutsList.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "BlockTypeSetListTimeoutsListStructList",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`single block type 1`] = `
"// https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/single_block_type
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface SingleBlockTypeConfig extends cdktf.TerraformMetaArguments {
  /**
  * timeouts block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/single_block_type#timeouts SingleBlockType#timeouts}
  */
  readonly timeouts?: SingleBlockTypeTimeouts;
}
export interface SingleBlockTypeTimeouts {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/single_block_type#create SingleBlockType#create}
  */
  readonly create?: string;
}

export function singleBlockTypeTimeoutsToTerraform(struct?: SingleBlockTypeTimeouts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    create: cdktf.stringToTerraform(struct!.create),
  }
}


export function singleBlockTypeTimeoutsToHclTerraform(struct?: SingleBlockTypeTimeouts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    create: {
      value: cdktf.stringToHclTerraform(struct!.create),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SingleBlockTypeTimeoutsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SingleBlockTypeTimeouts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._create !== undefined) {
      hasAnyValues = true;
      internalValueResult.create = this._create;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SingleBlockTypeTimeouts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._create = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._create = value.create;
    }
  }

  // create - computed: false, optional: true, required: false
  private _create?: string; 
  public get create() {
    return this.getStringAttribute('create');
  }
  public set create(value: string) {
    this._create = value;
  }
  public resetCreate() {
    this._create = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createInput() {
    return this._create;
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/single_block_type aws_single_block_type}
*/
export class SingleBlockType extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aws_single_block_type";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a SingleBlockType resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the SingleBlockType to import
  * @param importFromId The id of the existing SingleBlockType that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/single_block_type#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the SingleBlockType to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aws_single_block_type", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/single_block_type aws_single_block_type} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options SingleBlockTypeConfig = {}
  */
  public constructor(scope: Construct, id: string, config: SingleBlockTypeConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_single_block_type',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._timeouts.internalValue = config.timeouts;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // timeouts - computed: false, optional: true, required: false
  private _timeouts = new SingleBlockTypeTimeoutsOutputReference(this, "timeouts");
  public get timeouts() {
    return this._timeouts;
  }
  public putTimeouts(value: SingleBlockTypeTimeouts) {
    this._timeouts.internalValue = value;
  }
  public resetTimeouts() {
    this._timeouts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutsInput() {
    return this._timeouts.internalValue;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      timeouts: singleBlockTypeTimeoutsToTerraform(this._timeouts.internalValue),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      timeouts: {
        value: singleBlockTypeTimeoutsToHclTerraform(this._timeouts.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "SingleBlockTypeTimeouts",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`string list attribute 1`] = `
"// https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/string_list
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface StringListConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/string_list#subject_alternative_names_optional_computed StringList#subject_alternative_names_optional_computed}
  */
  readonly subjectAlternativeNamesOptionalComputed?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/string_list#subject_alternative_names_required StringList#subject_alternative_names_required}
  */
  readonly subjectAlternativeNamesRequired: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/string_list#subject_alternative_names_optional StringList#subject_alternative_names_optional}
  */
  readonly subjectAlternativeNamesOptional?: string[];
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/string_list aws_string_list}
*/
export class StringList extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aws_string_list";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a StringList resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the StringList to import
  * @param importFromId The id of the existing StringList that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/string_list#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the StringList to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aws_string_list", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/string_list aws_string_list} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options StringListConfig
  */
  public constructor(scope: Construct, id: string, config: StringListConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_string_list',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._subjectAlternativeNamesOptionalComputed = config.subjectAlternativeNamesOptionalComputed;
    this._subjectAlternativeNamesRequired = config.subjectAlternativeNamesRequired;
    this._subjectAlternativeNamesOptional = config.subjectAlternativeNamesOptional;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // subject_alternative_names_optional_computed - computed: true, optional: true, required: false
  private _subjectAlternativeNamesOptionalComputed?: string[]; 
  public get subjectAlternativeNamesOptionalComputed() {
    return this.getListAttribute('subject_alternative_names_optional_computed');
  }
  public set subjectAlternativeNamesOptionalComputed(value: string[]) {
    this._subjectAlternativeNamesOptionalComputed = value;
  }
  public resetSubjectAlternativeNamesOptionalComputed() {
    this._subjectAlternativeNamesOptionalComputed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectAlternativeNamesOptionalComputedInput() {
    return this._subjectAlternativeNamesOptionalComputed;
  }

  // subject_alternative_names_computed - computed: true, optional: false, required: false
  public get subjectAlternativeNamesComputed() {
    return this.getListAttribute('subject_alternative_names_computed');
  }

  // subject_alternative_names_required - computed: false, optional: false, required: true
  private _subjectAlternativeNamesRequired?: string[]; 
  public get subjectAlternativeNamesRequired() {
    return this.getListAttribute('subject_alternative_names_required');
  }
  public set subjectAlternativeNamesRequired(value: string[]) {
    this._subjectAlternativeNamesRequired = value;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectAlternativeNamesRequiredInput() {
    return this._subjectAlternativeNamesRequired;
  }

  // subject_alternative_names_optional - computed: false, optional: true, required: false
  private _subjectAlternativeNamesOptional?: string[]; 
  public get subjectAlternativeNamesOptional() {
    return this.getListAttribute('subject_alternative_names_optional');
  }
  public set subjectAlternativeNamesOptional(value: string[]) {
    this._subjectAlternativeNamesOptional = value;
  }
  public resetSubjectAlternativeNamesOptional() {
    this._subjectAlternativeNamesOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectAlternativeNamesOptionalInput() {
    return this._subjectAlternativeNamesOptional;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      subject_alternative_names_optional_computed: cdktf.listMapper(cdktf.stringToTerraform, false)(this._subjectAlternativeNamesOptionalComputed),
      subject_alternative_names_required: cdktf.listMapper(cdktf.stringToTerraform, false)(this._subjectAlternativeNamesRequired),
      subject_alternative_names_optional: cdktf.listMapper(cdktf.stringToTerraform, false)(this._subjectAlternativeNamesOptional),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      subject_alternative_names_optional_computed: {
        value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(this._subjectAlternativeNamesOptionalComputed),
        isBlock: false,
        type: "list",
        storageClassType: "stringList",
      },
      subject_alternative_names_required: {
        value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(this._subjectAlternativeNamesRequired),
        isBlock: false,
        type: "list",
        storageClassType: "stringList",
      },
      subject_alternative_names_optional: {
        value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(this._subjectAlternativeNamesOptional),
        isBlock: false,
        type: "list",
        storageClassType: "stringList",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;

exports[`string map attribute 1`] = `
"// https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/string_map
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface StringMapConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/string_map#subject_alternative_names_computed_optional StringMap#subject_alternative_names_computed_optional}
  */
  readonly subjectAlternativeNamesComputedOptional?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/string_map#subject_alternative_names_optional StringMap#subject_alternative_names_optional}
  */
  readonly subjectAlternativeNamesOptional?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/string_map#subject_alternative_names_required StringMap#subject_alternative_names_required}
  */
  readonly subjectAlternativeNamesRequired: { [key: string]: string };
}

/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/string_map aws_string_map}
*/
export class StringMap extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aws_string_map";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a StringMap resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the StringMap to import
  * @param importFromId The id of the existing StringMap that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/string_map#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the StringMap to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aws_string_map", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/string_map aws_string_map} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options StringMapConfig = {}
  */
  public constructor(scope: Construct, id: string, config: StringMapConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_string_map',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._subjectAlternativeNamesComputedOptional = config.subjectAlternativeNamesComputedOptional;
    this._subjectAlternativeNamesOptional = config.subjectAlternativeNamesOptional;
    this._subjectAlternativeNamesRequired = config.subjectAlternativeNamesRequired;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // subject_alternative_names_computed - computed: true, optional: false, required: false
  private _subjectAlternativeNamesComputed = new cdktf.StringMap(this, "subject_alternative_names_computed");
  public get subjectAlternativeNamesComputed() {
    return this._subjectAlternativeNamesComputed;
  }

  // subject_alternative_names_computed_optional - computed: true, optional: true, required: false
  private _subjectAlternativeNamesComputedOptional?: { [key: string]: string }; 
  public get subjectAlternativeNamesComputedOptional() {
    return this.getStringMapAttribute('subject_alternative_names_computed_optional');
  }
  public set subjectAlternativeNamesComputedOptional(value: { [key: string]: string }) {
    this._subjectAlternativeNamesComputedOptional = value;
  }
  public resetSubjectAlternativeNamesComputedOptional() {
    this._subjectAlternativeNamesComputedOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectAlternativeNamesComputedOptionalInput() {
    return this._subjectAlternativeNamesComputedOptional;
  }

  // subject_alternative_names_optional - computed: false, optional: true, required: false
  private _subjectAlternativeNamesOptional?: { [key: string]: string }; 
  public get subjectAlternativeNamesOptional() {
    return this.getStringMapAttribute('subject_alternative_names_optional');
  }
  public set subjectAlternativeNamesOptional(value: { [key: string]: string }) {
    this._subjectAlternativeNamesOptional = value;
  }
  public resetSubjectAlternativeNamesOptional() {
    this._subjectAlternativeNamesOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectAlternativeNamesOptionalInput() {
    return this._subjectAlternativeNamesOptional;
  }

  // subject_alternative_names_required - computed: true, optional: false, required: true
  private _subjectAlternativeNamesRequired?: { [key: string]: string }; 
  public get subjectAlternativeNamesRequired() {
    return this.getStringMapAttribute('subject_alternative_names_required');
  }
  public set subjectAlternativeNamesRequired(value: { [key: string]: string }) {
    this._subjectAlternativeNamesRequired = value;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectAlternativeNamesRequiredInput() {
    return this._subjectAlternativeNamesRequired;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      subject_alternative_names_computed_optional: cdktf.hashMapper(cdktf.stringToTerraform)(this._subjectAlternativeNamesComputedOptional),
      subject_alternative_names_optional: cdktf.hashMapper(cdktf.stringToTerraform)(this._subjectAlternativeNamesOptional),
      subject_alternative_names_required: cdktf.hashMapper(cdktf.stringToTerraform)(this._subjectAlternativeNamesRequired),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      subject_alternative_names_computed_optional: {
        value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(this._subjectAlternativeNamesComputedOptional),
        isBlock: false,
        type: "map",
        storageClassType: "stringMap",
      },
      subject_alternative_names_optional: {
        value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(this._subjectAlternativeNamesOptional),
        isBlock: false,
        type: "map",
        storageClassType: "stringMap",
      },
      subject_alternative_names_required: {
        value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(this._subjectAlternativeNamesRequired),
        isBlock: false,
        type: "map",
        storageClassType: "stringMap",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
"
`;
