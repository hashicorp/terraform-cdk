// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`boolean list attribute 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/boolean_list.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface BooleanListConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/boolean_list.html#foo_required BooleanList#foo_required}
  */
  readonly fooRequired: boolean[];
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/boolean_list.html#foo_optional BooleanList#foo_optional}
  */
  readonly fooOptional?: boolean[];
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/boolean_list.html aws_boolean_list}
*/
export class BooleanList extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType: string = \\"aws_boolean_list\\";

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/boolean_list.html aws_boolean_list} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options BooleanListConfig
  */
  public constructor(scope: Construct, id: string, config: BooleanListConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_boolean_list',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._fooRequired = config.fooRequired;
    this._fooOptional = config.fooOptional;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_required - computed: false, optional: false, required: true
  private _fooRequired?: boolean[]; 
  public get fooRequired() {
    return this.getBooleanAttribute('foo_required') as any;
  }
  public set fooRequired(value: boolean[]) {
    this._fooRequired = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fooRequiredInput() {
    return this._fooRequired
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional?: boolean[] | undefined; 
  public get fooOptional() {
    return this.getBooleanAttribute('foo_optional') as any;
  }
  public set fooOptional(value: boolean[] | undefined) {
    this._fooOptional = value;
  }
  public resetFooOptional() {
    this._fooOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooOptionalInput() {
    return this._fooOptional
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_required: cdktf.listMapper(cdktf.booleanToTerraform)(this._fooRequired),
      foo_optional: cdktf.listMapper(cdktf.booleanToTerraform)(this._fooOptional),
    };
  }
}
"
`;

exports[`boolean map attribute 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/boolean_map.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface BooleanMapConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/boolean_map.html#foo_computed_optional BooleanMap#foo_computed_optional}
  */
  readonly fooComputedOptional?: { [key: string]: boolean } | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/boolean_map.html#foo_optional BooleanMap#foo_optional}
  */
  readonly fooOptional?: { [key: string]: boolean } | cdktf.IResolvable;
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/boolean_map.html aws_boolean_map}
*/
export class BooleanMap extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType: string = \\"aws_boolean_map\\";

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/boolean_map.html aws_boolean_map} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options BooleanMapConfig = {}
  */
  public constructor(scope: Construct, id: string, config: BooleanMapConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_boolean_map',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._fooComputedOptional = config.fooComputedOptional;
    this._fooOptional = config.fooOptional;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_computed - computed: true, optional: false, required: false
  public fooComputed(key: string): boolean {
    return new cdktf.BooleanMap(this, 'foo_computed').lookup(key);
  }

  // foo_computed_optional - computed: true, optional: true, required: false
  private _fooComputedOptional?: { [key: string]: boolean } | cdktf.IResolvable | undefined; 
  public get fooComputedOptional() {
    return this.getBooleanAttribute('foo_computed_optional') as any;
  }
  public set fooComputedOptional(value: { [key: string]: boolean } | cdktf.IResolvable | undefined) {
    this._fooComputedOptional = value;
  }
  public resetFooComputedOptional() {
    this._fooComputedOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooComputedOptionalInput() {
    return this._fooComputedOptional
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional?: { [key: string]: boolean } | cdktf.IResolvable | undefined; 
  public get fooOptional() {
    return this.getBooleanAttribute('foo_optional') as any;
  }
  public set fooOptional(value: { [key: string]: boolean } | cdktf.IResolvable | undefined) {
    this._fooOptional = value;
  }
  public resetFooOptional() {
    this._fooOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooOptionalInput() {
    return this._fooOptional
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_computed_optional: cdktf.hashMapper(cdktf.anyToTerraform)(this._fooComputedOptional),
      foo_optional: cdktf.hashMapper(cdktf.anyToTerraform)(this._fooOptional),
    };
  }
}
"
`;

exports[`computed complex attribute 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/computed_complex.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface ComputedComplexConfig extends cdktf.TerraformMetaArguments {
}
export class ComputedComplexEgress extends cdktf.ComplexComputedList {

  // cidr_blocks - computed: true, optional: false, required: false
  public get cidrBlocks() {
    return this.getListAttribute('cidr_blocks');
  }

  // description - computed: true, optional: false, required: false
  public get description() {
    return this.getStringAttribute('description');
  }

  // from_port - computed: true, optional: false, required: false
  public get fromPort() {
    return this.getNumberAttribute('from_port');
  }

  // ipv6_cidr_blocks - computed: true, optional: false, required: false
  public get ipv6CidrBlocks() {
    return this.getListAttribute('ipv6_cidr_blocks');
  }

  // prefix_list_ids - computed: true, optional: false, required: false
  public get prefixListIds() {
    return this.getListAttribute('prefix_list_ids');
  }

  // protocol - computed: true, optional: false, required: false
  public get protocol() {
    return this.getStringAttribute('protocol');
  }

  // security_groups - computed: true, optional: false, required: false
  public get securityGroups() {
    return this.getListAttribute('security_groups');
  }

  // self - computed: true, optional: false, required: false
  public get selfAttribute() {
    return this.getBooleanAttribute('self') as any;
  }

  // to_port - computed: true, optional: false, required: false
  public get toPort() {
    return this.getNumberAttribute('to_port');
  }
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/computed_complex.html aws_computed_complex}
*/
export class ComputedComplex extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType: string = \\"aws_computed_complex\\";

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/computed_complex.html aws_computed_complex} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options ComputedComplexConfig = {}
  */
  public constructor(scope: Construct, id: string, config: ComputedComplexConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_computed_complex',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // egress - computed: true, optional: false, required: false
  public egress(index: string) {
    return new ComputedComplexEgress(this, 'egress', index);
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
    };
  }
}
"
`;

exports[`computed complex nested attribute 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/computed_complex_nested.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface ComputedComplexNestedConfig extends cdktf.TerraformMetaArguments {
}
export class ComputedComplexNestedResourcesAutoscalingGroups extends cdktf.ComplexComputedList {

  // name - computed: true, optional: false, required: false
  public get name() {
    return this.getStringAttribute('name');
  }
}
export class ComputedComplexNestedResources extends cdktf.ComplexComputedList {

  // autoscaling_groups - computed: true, optional: false, required: false
  public get autoscalingGroups() {
    // Getting the computed value is not yet implemented
    return this.interpolationForAttribute('autoscaling_groups') as any;
  }

  // remote_access_security_group_id - computed: true, optional: false, required: false
  public get remoteAccessSecurityGroupId() {
    return this.getStringAttribute('remote_access_security_group_id');
  }
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/computed_complex_nested.html aws_computed_complex_nested}
*/
export class ComputedComplexNested extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType: string = \\"aws_computed_complex_nested\\";

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/computed_complex_nested.html aws_computed_complex_nested} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options ComputedComplexNestedConfig = {}
  */
  public constructor(scope: Construct, id: string, config: ComputedComplexNestedConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_computed_complex_nested',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // resources - computed: true, optional: false, required: false
  public resources(index: string) {
    return new ComputedComplexNestedResources(this, 'resources', index);
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
    };
  }
}
"
`;

exports[`computed nested complex list block type 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/block_type_nested_computed_list.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface BlockTypeNestedComputedListConfig extends cdktf.TerraformMetaArguments {
  /**
  * inputs block
  * 
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/block_type_nested_computed_list.html#inputs BlockTypeNestedComputedList#inputs}
  */
  readonly inputs?: BlockTypeNestedComputedListInputs[];
}
export interface BlockTypeNestedComputedListInputs {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/block_type_nested_computed_list.html#name_prefix BlockTypeNestedComputedList#name_prefix}
  */
  readonly namePrefix: string;
}

function blockTypeNestedComputedListInputsToTerraform(struct?: BlockTypeNestedComputedListInputs): any {
  if (!cdktf.canInspect(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error(\\"A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration\\");
  }
  return {
    name_prefix: cdktf.stringToTerraform(struct!.namePrefix),
  }
}


/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/block_type_nested_computed_list.html aws_block_type_nested_computed_list}
*/
export class BlockTypeNestedComputedList extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType: string = \\"aws_block_type_nested_computed_list\\";

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/block_type_nested_computed_list.html aws_block_type_nested_computed_list} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options BlockTypeNestedComputedListConfig = {}
  */
  public constructor(scope: Construct, id: string, config: BlockTypeNestedComputedListConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_block_type_nested_computed_list',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._inputs = config.inputs;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // inputs - computed: false, optional: true, required: false
  private _inputs?: BlockTypeNestedComputedListInputs[] | undefined; 
  public get inputs() {
    // Getting the computed value is not yet implemented
    return this.interpolationForAttribute('inputs') as any;
  }
  public set inputs(value: BlockTypeNestedComputedListInputs[] | undefined) {
    this._inputs = value;
  }
  public resetInputs() {
    this._inputs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inputsInput() {
    return this._inputs
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      inputs: cdktf.listMapper(blockTypeNestedComputedListInputsToTerraform)(this._inputs),
    };
  }
}
"
`;

exports[`computed optional complex attribute 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface ComputedOptionalComplexConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html#egress ComputedOptionalComplex#egress}
  */
  readonly egress?: ComputedOptionalComplexEgress[];
}
export interface ComputedOptionalComplexEgress {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html#cidr_blocks ComputedOptionalComplex#cidr_blocks}
  */
  readonly cidrBlocks?: string[];
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html#description ComputedOptionalComplex#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html#from_port ComputedOptionalComplex#from_port}
  */
  readonly fromPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html#ipv6_cidr_blocks ComputedOptionalComplex#ipv6_cidr_blocks}
  */
  readonly ipv6CidrBlocks?: string[];
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html#prefix_list_ids ComputedOptionalComplex#prefix_list_ids}
  */
  readonly prefixListIds?: string[];
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html#protocol ComputedOptionalComplex#protocol}
  */
  readonly protocol?: string;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html#security_groups ComputedOptionalComplex#security_groups}
  */
  readonly securityGroups?: string[];
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html#self ComputedOptionalComplex#self}
  */
  readonly selfAttribute?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html#to_port ComputedOptionalComplex#to_port}
  */
  readonly toPort?: number;
}

function computedOptionalComplexEgressToTerraform(struct?: ComputedOptionalComplexEgress): any {
  if (!cdktf.canInspect(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error(\\"A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration\\");
  }
  return {
    cidr_blocks: cdktf.listMapper(cdktf.stringToTerraform)(struct!.cidrBlocks),
    description: cdktf.stringToTerraform(struct!.description),
    from_port: cdktf.numberToTerraform(struct!.fromPort),
    ipv6_cidr_blocks: cdktf.listMapper(cdktf.stringToTerraform)(struct!.ipv6CidrBlocks),
    prefix_list_ids: cdktf.listMapper(cdktf.stringToTerraform)(struct!.prefixListIds),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    security_groups: cdktf.listMapper(cdktf.stringToTerraform)(struct!.securityGroups),
    self: cdktf.booleanToTerraform(struct!.selfAttribute),
    to_port: cdktf.numberToTerraform(struct!.toPort),
  }
}


/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html aws_computed_optional_complex}
*/
export class ComputedOptionalComplex extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType: string = \\"aws_computed_optional_complex\\";

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html aws_computed_optional_complex} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options ComputedOptionalComplexConfig = {}
  */
  public constructor(scope: Construct, id: string, config: ComputedOptionalComplexConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_computed_optional_complex',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._egress = config.egress;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // egress - computed: true, optional: true, required: false
  private _egress?: ComputedOptionalComplexEgress[] | undefined; 
  public get egress() {
    // Getting the computed value is not yet implemented
    return this.interpolationForAttribute('egress') as any;
  }
  public set egress(value: ComputedOptionalComplexEgress[] | undefined) {
    this._egress = value;
  }
  public resetEgress() {
    this._egress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressInput() {
    return this._egress
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      egress: cdktf.listMapper(computedOptionalComplexEgressToTerraform)(this._egress),
    };
  }
}
"
`;

exports[`deeply nested block types 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/deeply_nested_block_types.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface DeeplyNestedBlockTypesConfig extends cdktf.TerraformMetaArguments {
  /**
  * lifecycle_rule block
  * 
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/deeply_nested_block_types.html#lifecycle_rule DeeplyNestedBlockTypes#lifecycle_rule}
  */
  readonly lifecycleRule?: DeeplyNestedBlockTypesLifecycleRule[];
}
export interface DeeplyNestedBlockTypesLifecycleRuleExpiration {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/deeply_nested_block_types.html#date DeeplyNestedBlockTypes#date}
  */
  readonly date?: string;
}

function deeplyNestedBlockTypesLifecycleRuleExpirationToTerraform(struct?: DeeplyNestedBlockTypesLifecycleRuleExpirationOutput | DeeplyNestedBlockTypesLifecycleRuleExpiration): any {
  if (!cdktf.canInspect(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error(\\"A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration\\");
  }
  return {
    date: cdktf.stringToTerraform(struct!.date),
  }
}

export class DeeplyNestedBlockTypesLifecycleRuleExpirationOutput extends cdktf.ComplexObject {
  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param isSingleItem True if this is a block, false if it's a list
  */
  public constructor(terraformResource: cdktf.ITerraformResource, terraformAttribute: string, isSingleItem: boolean) {
    super(terraformResource, terraformAttribute, isSingleItem);
  }

  // date - computed: false, optional: true, required: false
  private _date?: string | undefined; 
  public get date() {
    return this.getStringAttribute('date');
  }
  public set date(value: string | undefined) {
    this._date = value;
  }
  public resetDate() {
    this._date = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dateInput() {
    return this._date
  }
}
export interface DeeplyNestedBlockTypesLifecycleRule {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/deeply_nested_block_types.html#abort_incomplete_multipart_upload_days DeeplyNestedBlockTypes#abort_incomplete_multipart_upload_days}
  */
  readonly abortIncompleteMultipartUploadDays?: number;
  /**
  * expiration block
  * 
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/deeply_nested_block_types.html#expiration DeeplyNestedBlockTypes#expiration}
  */
  readonly expiration?: DeeplyNestedBlockTypesLifecycleRuleExpiration;
}

function deeplyNestedBlockTypesLifecycleRuleToTerraform(struct?: DeeplyNestedBlockTypesLifecycleRule): any {
  if (!cdktf.canInspect(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error(\\"A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration\\");
  }
  return {
    abort_incomplete_multipart_upload_days: cdktf.numberToTerraform(struct!.abortIncompleteMultipartUploadDays),
    expiration: deeplyNestedBlockTypesLifecycleRuleExpirationToTerraform(struct!.expiration),
  }
}


/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/deeply_nested_block_types.html aws_deeply_nested_block_types}
*/
export class DeeplyNestedBlockTypes extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType: string = \\"aws_deeply_nested_block_types\\";

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/deeply_nested_block_types.html aws_deeply_nested_block_types} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options DeeplyNestedBlockTypesConfig = {}
  */
  public constructor(scope: Construct, id: string, config: DeeplyNestedBlockTypesConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_deeply_nested_block_types',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._lifecycleRule = config.lifecycleRule;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // lifecycle_rule - computed: false, optional: true, required: false
  private _lifecycleRule?: DeeplyNestedBlockTypesLifecycleRule[] | undefined; 
  public get lifecycleRule() {
    // Getting the computed value is not yet implemented
    return this.interpolationForAttribute('lifecycle_rule') as any;
  }
  public set lifecycleRule(value: DeeplyNestedBlockTypesLifecycleRule[] | undefined) {
    this._lifecycleRule = value;
  }
  public resetLifecycleRule() {
    this._lifecycleRule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lifecycleRuleInput() {
    return this._lifecycleRule
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      lifecycle_rule: cdktf.listMapper(deeplyNestedBlockTypesLifecycleRuleToTerraform)(this._lifecycleRule),
    };
  }
}
"
`;

exports[`ignored attributes 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/ignored_attributes.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface IgnoredAttributesConfig extends cdktf.TerraformMetaArguments {
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/ignored_attributes.html aws_ignored_attributes}
*/
export class IgnoredAttributes extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType: string = \\"aws_ignored_attributes\\";

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/ignored_attributes.html aws_ignored_attributes} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options IgnoredAttributesConfig = {}
  */
  public constructor(scope: Construct, id: string, config: IgnoredAttributesConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_ignored_attributes',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // id - computed: true, optional: true, required: false
  public get id() {
    return this.getStringAttribute('id');
  }

  // arn - computed: true, optional: false, required: false
  public get arn() {
    return this.getStringAttribute('arn');
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
    };
  }
}
"
`;

exports[`incompatible attribute names 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/incompatible_attribute_names.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface IncompatibleAttributeNamesConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/incompatible_attribute_names.html#get_password_data IncompatibleAttributeNames#get_password_data}
  */
  readonly fetchPasswordData?: string;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/incompatible_attribute_names.html#self IncompatibleAttributeNames#self}
  */
  readonly selfAttribute: string;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/incompatible_attribute_names.html#equals IncompatibleAttributeNames#equals}
  */
  readonly equalTo: string;
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/incompatible_attribute_names.html aws_incompatible_attribute_names}
*/
export class IncompatibleAttributeNames extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType: string = \\"aws_incompatible_attribute_names\\";

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/incompatible_attribute_names.html aws_incompatible_attribute_names} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options IncompatibleAttributeNamesConfig
  */
  public constructor(scope: Construct, id: string, config: IncompatibleAttributeNamesConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_incompatible_attribute_names',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._getPasswordData = config.fetchPasswordData;
    this._self = config.selfAttribute;
    this._equals = config.equalTo;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // get_password_data - computed: false, optional: true, required: false
  private _getPasswordData?: string | undefined; 
  public get fetchPasswordData() {
    return this.getStringAttribute('get_password_data');
  }
  public set fetchPasswordData(value: string | undefined) {
    this._getPasswordData = value;
  }
  public resetFetchPasswordData() {
    this._getPasswordData = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fetchPasswordDataInput() {
    return this._getPasswordData
  }

  // self - computed: false, optional: false, required: true
  private _self?: string; 
  public get selfAttribute() {
    return this.getStringAttribute('self');
  }
  public set selfAttribute(value: string) {
    this._self = value;
  }
  // Temporarily expose input value. Use with caution.
  public get selfAttributeInput() {
    return this._self
  }

  // equals - computed: false, optional: false, required: true
  private _equals?: string; 
  public get equalTo() {
    return this.getStringAttribute('equals');
  }
  public set equalTo(value: string) {
    this._equals = value;
  }
  // Temporarily expose input value. Use with caution.
  public get equalToInput() {
    return this._equals
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      get_password_data: cdktf.stringToTerraform(this._getPasswordData),
      self: cdktf.stringToTerraform(this._self),
      equals: cdktf.stringToTerraform(this._equals),
    };
  }
}
"
`;

exports[`list of string map attribute 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/list_of_string_map.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface ListOfStringMapConfig extends cdktf.TerraformMetaArguments {
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/list_of_string_map.html aws_list_of_string_map}
*/
export class ListOfStringMap extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType: string = \\"aws_list_of_string_map\\";

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/list_of_string_map.html aws_list_of_string_map} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options ListOfStringMapConfig = {}
  */
  public constructor(scope: Construct, id: string, config: ListOfStringMapConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_list_of_string_map',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // keys - computed: true, optional: false, required: false
  public keys(index: string, key: string): string {
    return new cdktf.StringMap(this, \`keys.\${index}\`).lookup(key);
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
    };
  }
}
"
`;

exports[`number list attribute 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/number_list.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface NumberListConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/number_list.html#foo_required NumberList#foo_required}
  */
  readonly fooRequired: number[];
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/number_list.html#foo_optional NumberList#foo_optional}
  */
  readonly fooOptional?: number[];
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/number_list.html aws_number_list}
*/
export class NumberList extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType: string = \\"aws_number_list\\";

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/number_list.html aws_number_list} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options NumberListConfig
  */
  public constructor(scope: Construct, id: string, config: NumberListConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_number_list',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._fooRequired = config.fooRequired;
    this._fooOptional = config.fooOptional;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_required - computed: false, optional: false, required: true
  private _fooRequired?: number[]; 
  public get fooRequired() {
    // Getting the computed value is not yet implemented
    return this.interpolationForAttribute('foo_required') as any;
  }
  public set fooRequired(value: number[]) {
    this._fooRequired = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fooRequiredInput() {
    return this._fooRequired
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional?: number[] | undefined; 
  public get fooOptional() {
    // Getting the computed value is not yet implemented
    return this.interpolationForAttribute('foo_optional') as any;
  }
  public set fooOptional(value: number[] | undefined) {
    this._fooOptional = value;
  }
  public resetFooOptional() {
    this._fooOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooOptionalInput() {
    return this._fooOptional
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_required: cdktf.listMapper(cdktf.numberToTerraform)(this._fooRequired),
      foo_optional: cdktf.listMapper(cdktf.numberToTerraform)(this._fooOptional),
    };
  }
}
"
`;

exports[`number map attribute 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/number_map.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface NumberMapConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/number_map.html#foo_computed_optional NumberMap#foo_computed_optional}
  */
  readonly fooComputedOptional?: { [key: string]: number } | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/number_map.html#foo_optional NumberMap#foo_optional}
  */
  readonly fooOptional?: { [key: string]: number } | cdktf.IResolvable;
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/number_map.html aws_number_map}
*/
export class NumberMap extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType: string = \\"aws_number_map\\";

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/number_map.html aws_number_map} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options NumberMapConfig = {}
  */
  public constructor(scope: Construct, id: string, config: NumberMapConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_number_map',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._fooComputedOptional = config.fooComputedOptional;
    this._fooOptional = config.fooOptional;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_computed - computed: true, optional: false, required: false
  public fooComputed(key: string): number {
    return new cdktf.NumberMap(this, 'foo_computed').lookup(key);
  }

  // foo_computed_optional - computed: true, optional: true, required: false
  private _fooComputedOptional?: { [key: string]: number } | cdktf.IResolvable | undefined; 
  public get fooComputedOptional() {
    // Getting the computed value is not yet implemented
    return this.interpolationForAttribute('foo_computed_optional') as any;
  }
  public set fooComputedOptional(value: { [key: string]: number } | cdktf.IResolvable | undefined) {
    this._fooComputedOptional = value;
  }
  public resetFooComputedOptional() {
    this._fooComputedOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooComputedOptionalInput() {
    return this._fooComputedOptional
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional?: { [key: string]: number } | cdktf.IResolvable | undefined; 
  public get fooOptional() {
    // Getting the computed value is not yet implemented
    return this.interpolationForAttribute('foo_optional') as any;
  }
  public set fooOptional(value: { [key: string]: number } | cdktf.IResolvable | undefined) {
    this._fooOptional = value;
  }
  public resetFooOptional() {
    this._fooOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooOptionalInput() {
    return this._fooOptional
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_computed_optional: cdktf.hashMapper(cdktf.anyToTerraform)(this._fooComputedOptional),
      foo_optional: cdktf.hashMapper(cdktf.anyToTerraform)(this._fooOptional),
    };
  }
}
"
`;

exports[`primitive boolean 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/primitive_boolean.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface PrimitiveBooleanConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_boolean.html#foo_computed_optional PrimitiveBoolean#foo_computed_optional}
  */
  readonly fooComputedOptional?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_boolean.html#foo_optional PrimitiveBoolean#foo_optional}
  */
  readonly fooOptional?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_boolean.html#foo_required PrimitiveBoolean#foo_required}
  */
  readonly fooRequired: boolean | cdktf.IResolvable;
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/primitive_boolean.html aws_primitive_boolean}
*/
export class PrimitiveBoolean extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType: string = \\"aws_primitive_boolean\\";

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/primitive_boolean.html aws_primitive_boolean} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options PrimitiveBooleanConfig
  */
  public constructor(scope: Construct, id: string, config: PrimitiveBooleanConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_primitive_boolean',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._fooComputedOptional = config.fooComputedOptional;
    this._fooOptional = config.fooOptional;
    this._fooRequired = config.fooRequired;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_computed - computed: true, optional: false, required: false
  public get fooComputed() {
    return this.getBooleanAttribute('foo_computed') as any;
  }

  // foo_computed_optional - computed: true, optional: true, required: false
  private _fooComputedOptional?: boolean | cdktf.IResolvable | undefined; 
  public get fooComputedOptional() {
    return this.getBooleanAttribute('foo_computed_optional') as any;
  }
  public set fooComputedOptional(value: boolean | cdktf.IResolvable | undefined) {
    this._fooComputedOptional = value;
  }
  public resetFooComputedOptional() {
    this._fooComputedOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooComputedOptionalInput() {
    return this._fooComputedOptional
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional?: boolean | cdktf.IResolvable | undefined; 
  public get fooOptional() {
    return this.getBooleanAttribute('foo_optional') as any;
  }
  public set fooOptional(value: boolean | cdktf.IResolvable | undefined) {
    this._fooOptional = value;
  }
  public resetFooOptional() {
    this._fooOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooOptionalInput() {
    return this._fooOptional
  }

  // foo_required - computed: false, optional: false, required: true
  private _fooRequired?: boolean | cdktf.IResolvable; 
  public get fooRequired() {
    return this.getBooleanAttribute('foo_required') as any;
  }
  public set fooRequired(value: boolean | cdktf.IResolvable) {
    this._fooRequired = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fooRequiredInput() {
    return this._fooRequired
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_computed_optional: cdktf.booleanToTerraform(this._fooComputedOptional),
      foo_optional: cdktf.booleanToTerraform(this._fooOptional),
      foo_required: cdktf.booleanToTerraform(this._fooRequired),
    };
  }
}
"
`;

exports[`primitive dynamic 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/primitive_dynamic.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface PrimitiveDynamicConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_dynamic.html#foo_computed_optional PrimitiveDynamic#foo_computed_optional}
  */
  readonly fooComputedOptional?: { [key: string]: any } | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_dynamic.html#foo_optional PrimitiveDynamic#foo_optional}
  */
  readonly fooOptional?: { [key: string]: any } | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_dynamic.html#foo_required PrimitiveDynamic#foo_required}
  */
  readonly fooRequired: { [key: string]: any } | cdktf.IResolvable;
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/primitive_dynamic.html aws_primitive_dynamic}
*/
export class PrimitiveDynamic extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType: string = \\"aws_primitive_dynamic\\";

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/primitive_dynamic.html aws_primitive_dynamic} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options PrimitiveDynamicConfig
  */
  public constructor(scope: Construct, id: string, config: PrimitiveDynamicConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_primitive_dynamic',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._fooComputedOptional = config.fooComputedOptional;
    this._fooOptional = config.fooOptional;
    this._fooRequired = config.fooRequired;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_computed - computed: true, optional: false, required: false
  public fooComputed(key: string): any {
    return new { [key: string]: any } | cdktf.IResolvable(this, 'foo_computed').lookup(key);
  }

  // foo_computed_optional - computed: true, optional: true, required: false
  private _fooComputedOptional?: { [key: string]: any } | cdktf.IResolvable | undefined; 
  public get fooComputedOptional() {
    // Getting the computed value is not yet implemented
    return this.interpolationForAttribute('foo_computed_optional') as any;
  }
  public set fooComputedOptional(value: { [key: string]: any } | cdktf.IResolvable | undefined) {
    this._fooComputedOptional = value;
  }
  public resetFooComputedOptional() {
    this._fooComputedOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooComputedOptionalInput() {
    return this._fooComputedOptional
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional?: { [key: string]: any } | cdktf.IResolvable | undefined; 
  public get fooOptional() {
    // Getting the computed value is not yet implemented
    return this.interpolationForAttribute('foo_optional') as any;
  }
  public set fooOptional(value: { [key: string]: any } | cdktf.IResolvable | undefined) {
    this._fooOptional = value;
  }
  public resetFooOptional() {
    this._fooOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooOptionalInput() {
    return this._fooOptional
  }

  // foo_required - computed: false, optional: false, required: true
  private _fooRequired?: { [key: string]: any } | cdktf.IResolvable; 
  public get fooRequired() {
    // Getting the computed value is not yet implemented
    return this.interpolationForAttribute('foo_required') as any;
  }
  public set fooRequired(value: { [key: string]: any } | cdktf.IResolvable) {
    this._fooRequired = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fooRequiredInput() {
    return this._fooRequired
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_computed_optional: cdktf.hashMapper(cdktf.anyToTerraform)(this._fooComputedOptional),
      foo_optional: cdktf.hashMapper(cdktf.anyToTerraform)(this._fooOptional),
      foo_required: cdktf.hashMapper(cdktf.anyToTerraform)(this._fooRequired),
    };
  }
}
"
`;

exports[`primitive number 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/primitive_number.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface PrimitiveNumberConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_number.html#foo_computed_optional PrimitiveNumber#foo_computed_optional}
  */
  readonly fooComputedOptional?: number;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_number.html#foo_optional PrimitiveNumber#foo_optional}
  */
  readonly fooOptional?: number;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_number.html#foo_required PrimitiveNumber#foo_required}
  */
  readonly fooRequired: number;
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/primitive_number.html aws_primitive_number}
*/
export class PrimitiveNumber extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType: string = \\"aws_primitive_number\\";

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/primitive_number.html aws_primitive_number} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options PrimitiveNumberConfig
  */
  public constructor(scope: Construct, id: string, config: PrimitiveNumberConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_primitive_number',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._fooComputedOptional = config.fooComputedOptional;
    this._fooOptional = config.fooOptional;
    this._fooRequired = config.fooRequired;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_computed - computed: true, optional: false, required: false
  public get fooComputed() {
    return this.getNumberAttribute('foo_computed');
  }

  // foo_computed_optional - computed: true, optional: true, required: false
  private _fooComputedOptional?: number | undefined; 
  public get fooComputedOptional() {
    return this.getNumberAttribute('foo_computed_optional');
  }
  public set fooComputedOptional(value: number | undefined) {
    this._fooComputedOptional = value;
  }
  public resetFooComputedOptional() {
    this._fooComputedOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooComputedOptionalInput() {
    return this._fooComputedOptional
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional?: number | undefined; 
  public get fooOptional() {
    return this.getNumberAttribute('foo_optional');
  }
  public set fooOptional(value: number | undefined) {
    this._fooOptional = value;
  }
  public resetFooOptional() {
    this._fooOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooOptionalInput() {
    return this._fooOptional
  }

  // foo_required - computed: false, optional: false, required: true
  private _fooRequired?: number; 
  public get fooRequired() {
    return this.getNumberAttribute('foo_required');
  }
  public set fooRequired(value: number) {
    this._fooRequired = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fooRequiredInput() {
    return this._fooRequired
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_computed_optional: cdktf.numberToTerraform(this._fooComputedOptional),
      foo_optional: cdktf.numberToTerraform(this._fooOptional),
      foo_required: cdktf.numberToTerraform(this._fooRequired),
    };
  }
}
"
`;

exports[`primitive string 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/primitive_string.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface PrimitiveStringConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_string.html#foo_computed_optional PrimitiveString#foo_computed_optional}
  */
  readonly fooComputedOptional?: string;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_string.html#foo_optional PrimitiveString#foo_optional}
  */
  readonly fooOptional?: string;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_string.html#foo_required PrimitiveString#foo_required}
  */
  readonly fooRequired: string;
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/primitive_string.html aws_primitive_string}
*/
export class PrimitiveString extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType: string = \\"aws_primitive_string\\";

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/primitive_string.html aws_primitive_string} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options PrimitiveStringConfig
  */
  public constructor(scope: Construct, id: string, config: PrimitiveStringConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_primitive_string',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._fooComputedOptional = config.fooComputedOptional;
    this._fooOptional = config.fooOptional;
    this._fooRequired = config.fooRequired;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_computed - computed: true, optional: false, required: false
  public get fooComputed() {
    return this.getStringAttribute('foo_computed');
  }

  // foo_computed_optional - computed: true, optional: true, required: false
  private _fooComputedOptional?: string | undefined; 
  public get fooComputedOptional() {
    return this.getStringAttribute('foo_computed_optional');
  }
  public set fooComputedOptional(value: string | undefined) {
    this._fooComputedOptional = value;
  }
  public resetFooComputedOptional() {
    this._fooComputedOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooComputedOptionalInput() {
    return this._fooComputedOptional
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional?: string | undefined; 
  public get fooOptional() {
    return this.getStringAttribute('foo_optional');
  }
  public set fooOptional(value: string | undefined) {
    this._fooOptional = value;
  }
  public resetFooOptional() {
    this._fooOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fooOptionalInput() {
    return this._fooOptional
  }

  // foo_required - computed: false, optional: false, required: true
  private _fooRequired?: string; 
  public get fooRequired() {
    return this.getStringAttribute('foo_required');
  }
  public set fooRequired(value: string) {
    this._fooRequired = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fooRequiredInput() {
    return this._fooRequired
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_computed_optional: cdktf.stringToTerraform(this._fooComputedOptional),
      foo_optional: cdktf.stringToTerraform(this._fooOptional),
      foo_required: cdktf.stringToTerraform(this._fooRequired),
    };
  }
}
"
`;

exports[`reset and input name conflicts 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/name_conflict.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface NameConflictConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/name_conflict.html#values NameConflict#values}
  */
  readonly values?: string;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/name_conflict.html#reset_values NameConflict#reset_values}
  */
  readonly resetValues?: string;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/name_conflict.html#template NameConflict#template}
  */
  readonly template?: string;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/name_conflict.html#template_input NameConflict#template_input}
  */
  readonly templateInput?: string;
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/name_conflict.html aws_name_conflict}
*/
export class NameConflict extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType: string = \\"aws_name_conflict\\";

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/name_conflict.html aws_name_conflict} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options NameConflictConfig = {}
  */
  public constructor(scope: Construct, id: string, config: NameConflictConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_name_conflict',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._values = config.values;
    this._resetValues = config.resetValues;
    this._template = config.template;
    this._templateInput = config.templateInput;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // values - computed: false, optional: true, required: false
  private _values?: string | undefined; 
  public get values() {
    return this.getStringAttribute('values');
  }
  public set values(value: string | undefined) {
    this._values = value;
  }
  public resetTfValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values
  }

  // reset_values - computed: false, optional: true, required: false
  private _resetValues?: string | undefined; 
  public get resetValues() {
    return this.getStringAttribute('reset_values');
  }
  public set resetValues(value: string | undefined) {
    this._resetValues = value;
  }
  public resetResetValues() {
    this._resetValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resetValuesInput() {
    return this._resetValues
  }

  // template - computed: false, optional: true, required: false
  private _template?: string | undefined; 
  public get template() {
    return this.getStringAttribute('template');
  }
  public set template(value: string | undefined) {
    this._template = value;
  }
  public resetTemplate() {
    this._template = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateTfInput() {
    return this._template
  }

  // template_input - computed: false, optional: true, required: false
  private _templateInput?: string | undefined; 
  public get templateInput() {
    return this.getStringAttribute('template_input');
  }
  public set templateInput(value: string | undefined) {
    this._templateInput = value;
  }
  public resetTemplateInput() {
    this._templateInput = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInputInput() {
    return this._templateInput
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      values: cdktf.stringToTerraform(this._values),
      reset_values: cdktf.stringToTerraform(this._resetValues),
      template: cdktf.stringToTerraform(this._template),
      template_input: cdktf.stringToTerraform(this._templateInput),
    };
  }
}
"
`;

exports[`set / list block type 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/block_type_set_list.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface BlockTypeSetListConfig extends cdktf.TerraformMetaArguments {
  /**
  * timeouts_set block
  * 
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/block_type_set_list.html#timeouts_set BlockTypeSetList#timeouts_set}
  */
  readonly timeoutsSet?: BlockTypeSetListTimeoutsSet[];
  /**
  * timeouts_list block
  * 
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/block_type_set_list.html#timeouts_list BlockTypeSetList#timeouts_list}
  */
  readonly timeoutsList?: BlockTypeSetListTimeoutsList[];
}
export interface BlockTypeSetListTimeoutsSet {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/block_type_set_list.html#create BlockTypeSetList#create}
  */
  readonly create?: string;
}

function blockTypeSetListTimeoutsSetToTerraform(struct?: BlockTypeSetListTimeoutsSet): any {
  if (!cdktf.canInspect(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error(\\"A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration\\");
  }
  return {
    create: cdktf.stringToTerraform(struct!.create),
  }
}

export interface BlockTypeSetListTimeoutsList {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/block_type_set_list.html#create BlockTypeSetList#create}
  */
  readonly create?: string;
}

function blockTypeSetListTimeoutsListToTerraform(struct?: BlockTypeSetListTimeoutsList): any {
  if (!cdktf.canInspect(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error(\\"A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration\\");
  }
  return {
    create: cdktf.stringToTerraform(struct!.create),
  }
}


/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/block_type_set_list.html aws_block_type_set_list}
*/
export class BlockTypeSetList extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType: string = \\"aws_block_type_set_list\\";

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/block_type_set_list.html aws_block_type_set_list} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options BlockTypeSetListConfig = {}
  */
  public constructor(scope: Construct, id: string, config: BlockTypeSetListConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_block_type_set_list',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._timeoutsSet = config.timeoutsSet;
    this._timeoutsList = config.timeoutsList;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // timeouts_set - computed: false, optional: true, required: false
  private _timeoutsSet?: BlockTypeSetListTimeoutsSet[] | undefined; 
  public get timeoutsSet() {
    // Getting the computed value is not yet implemented
    return this.interpolationForAttribute('timeouts_set') as any;
  }
  public set timeoutsSet(value: BlockTypeSetListTimeoutsSet[] | undefined) {
    this._timeoutsSet = value;
  }
  public resetTimeoutsSet() {
    this._timeoutsSet = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutsSetInput() {
    return this._timeoutsSet
  }

  // timeouts_list - computed: false, optional: true, required: false
  private _timeoutsList?: BlockTypeSetListTimeoutsList[] | undefined; 
  public get timeoutsList() {
    // Getting the computed value is not yet implemented
    return this.interpolationForAttribute('timeouts_list') as any;
  }
  public set timeoutsList(value: BlockTypeSetListTimeoutsList[] | undefined) {
    this._timeoutsList = value;
  }
  public resetTimeoutsList() {
    this._timeoutsList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutsListInput() {
    return this._timeoutsList
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      timeouts_set: cdktf.listMapper(blockTypeSetListTimeoutsSetToTerraform)(this._timeoutsSet),
      timeouts_list: cdktf.listMapper(blockTypeSetListTimeoutsListToTerraform)(this._timeoutsList),
    };
  }
}
"
`;

exports[`single block type 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/single_block_type.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface SingleBlockTypeConfig extends cdktf.TerraformMetaArguments {
  /**
  * timeouts block
  * 
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/single_block_type.html#timeouts SingleBlockType#timeouts}
  */
  readonly timeouts?: SingleBlockTypeTimeouts;
}
export interface SingleBlockTypeTimeouts {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/single_block_type.html#create SingleBlockType#create}
  */
  readonly create?: string;
}

function singleBlockTypeTimeoutsToTerraform(struct?: SingleBlockTypeTimeoutsOutput | SingleBlockTypeTimeouts): any {
  if (!cdktf.canInspect(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error(\\"A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration\\");
  }
  return {
    create: cdktf.stringToTerraform(struct!.create),
  }
}

export class SingleBlockTypeTimeoutsOutput extends cdktf.ComplexObject {
  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param isSingleItem True if this is a block, false if it's a list
  */
  public constructor(terraformResource: cdktf.ITerraformResource, terraformAttribute: string, isSingleItem: boolean) {
    super(terraformResource, terraformAttribute, isSingleItem);
  }

  // create - computed: false, optional: true, required: false
  private _create?: string | undefined; 
  public get create() {
    return this.getStringAttribute('create');
  }
  public set create(value: string | undefined) {
    this._create = value;
  }
  public resetCreate() {
    this._create = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createInput() {
    return this._create
  }
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/single_block_type.html aws_single_block_type}
*/
export class SingleBlockType extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType: string = \\"aws_single_block_type\\";

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/single_block_type.html aws_single_block_type} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options SingleBlockTypeConfig = {}
  */
  public constructor(scope: Construct, id: string, config: SingleBlockTypeConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_single_block_type',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._timeouts = config.timeouts;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // timeouts - computed: false, optional: true, required: false
  private _timeouts?: SingleBlockTypeTimeouts | undefined; 
  private __timeoutsOutput = new SingleBlockTypeTimeoutsOutput(this as any, \\"timeouts\\", true);
  public get timeouts() {
    return this.__timeoutsOutput;
  }
  public putTimeouts(value: SingleBlockTypeTimeouts | undefined) {
    this._timeouts = value;
  }
  public resetTimeouts() {
    this._timeouts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutsInput() {
    return this._timeouts
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      timeouts: singleBlockTypeTimeoutsToTerraform(this._timeouts),
    };
  }
}
"
`;

exports[`string list attribute 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/string_list.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface StringListConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/string_list.html#subject_alternative_names_optional_computed StringList#subject_alternative_names_optional_computed}
  */
  readonly subjectAlternativeNamesOptionalComputed?: string[];
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/string_list.html#subject_alternative_names_required StringList#subject_alternative_names_required}
  */
  readonly subjectAlternativeNamesRequired: string[];
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/string_list.html#subject_alternative_names_optional StringList#subject_alternative_names_optional}
  */
  readonly subjectAlternativeNamesOptional?: string[];
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/string_list.html aws_string_list}
*/
export class StringList extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType: string = \\"aws_string_list\\";

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/string_list.html aws_string_list} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options StringListConfig
  */
  public constructor(scope: Construct, id: string, config: StringListConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_string_list',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._subjectAlternativeNamesOptionalComputed = config.subjectAlternativeNamesOptionalComputed;
    this._subjectAlternativeNamesRequired = config.subjectAlternativeNamesRequired;
    this._subjectAlternativeNamesOptional = config.subjectAlternativeNamesOptional;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // subject_alternative_names_optional_computed - computed: true, optional: true, required: false
  private _subjectAlternativeNamesOptionalComputed?: string[] | undefined; 
  public get subjectAlternativeNamesOptionalComputed() {
    return this.getListAttribute('subject_alternative_names_optional_computed');
  }
  public set subjectAlternativeNamesOptionalComputed(value: string[] | undefined) {
    this._subjectAlternativeNamesOptionalComputed = value;
  }
  public resetSubjectAlternativeNamesOptionalComputed() {
    this._subjectAlternativeNamesOptionalComputed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectAlternativeNamesOptionalComputedInput() {
    return this._subjectAlternativeNamesOptionalComputed
  }

  // subject_alternative_names_computed - computed: true, optional: false, required: false
  public get subjectAlternativeNamesComputed() {
    return this.getListAttribute('subject_alternative_names_computed');
  }

  // subject_alternative_names_required - computed: false, optional: false, required: true
  private _subjectAlternativeNamesRequired?: string[]; 
  public get subjectAlternativeNamesRequired() {
    return this.getListAttribute('subject_alternative_names_required');
  }
  public set subjectAlternativeNamesRequired(value: string[]) {
    this._subjectAlternativeNamesRequired = value;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectAlternativeNamesRequiredInput() {
    return this._subjectAlternativeNamesRequired
  }

  // subject_alternative_names_optional - computed: false, optional: true, required: false
  private _subjectAlternativeNamesOptional?: string[] | undefined; 
  public get subjectAlternativeNamesOptional() {
    return this.getListAttribute('subject_alternative_names_optional');
  }
  public set subjectAlternativeNamesOptional(value: string[] | undefined) {
    this._subjectAlternativeNamesOptional = value;
  }
  public resetSubjectAlternativeNamesOptional() {
    this._subjectAlternativeNamesOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectAlternativeNamesOptionalInput() {
    return this._subjectAlternativeNamesOptional
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      subject_alternative_names_optional_computed: cdktf.listMapper(cdktf.stringToTerraform)(this._subjectAlternativeNamesOptionalComputed),
      subject_alternative_names_required: cdktf.listMapper(cdktf.stringToTerraform)(this._subjectAlternativeNamesRequired),
      subject_alternative_names_optional: cdktf.listMapper(cdktf.stringToTerraform)(this._subjectAlternativeNamesOptional),
    };
  }
}
"
`;

exports[`string map attribute 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/string_map.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface StringMapConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/string_map.html#subject_alternative_names_computed_optional StringMap#subject_alternative_names_computed_optional}
  */
  readonly subjectAlternativeNamesComputedOptional?: { [key: string]: string } | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/string_map.html#subject_alternative_names_optional StringMap#subject_alternative_names_optional}
  */
  readonly subjectAlternativeNamesOptional?: { [key: string]: string } | cdktf.IResolvable;
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/string_map.html aws_string_map}
*/
export class StringMap extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType: string = \\"aws_string_map\\";

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/string_map.html aws_string_map} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options StringMapConfig = {}
  */
  public constructor(scope: Construct, id: string, config: StringMapConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_string_map',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._subjectAlternativeNamesComputedOptional = config.subjectAlternativeNamesComputedOptional;
    this._subjectAlternativeNamesOptional = config.subjectAlternativeNamesOptional;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // subject_alternative_names_computed - computed: true, optional: false, required: false
  public subjectAlternativeNamesComputed(key: string): string {
    return new cdktf.StringMap(this, 'subject_alternative_names_computed').lookup(key);
  }

  // subject_alternative_names_computed_optional - computed: true, optional: true, required: false
  private _subjectAlternativeNamesComputedOptional?: { [key: string]: string } | cdktf.IResolvable | undefined; 
  public get subjectAlternativeNamesComputedOptional() {
    // Getting the computed value is not yet implemented
    return this.interpolationForAttribute('subject_alternative_names_computed_optional') as any;
  }
  public set subjectAlternativeNamesComputedOptional(value: { [key: string]: string } | cdktf.IResolvable | undefined) {
    this._subjectAlternativeNamesComputedOptional = value;
  }
  public resetSubjectAlternativeNamesComputedOptional() {
    this._subjectAlternativeNamesComputedOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectAlternativeNamesComputedOptionalInput() {
    return this._subjectAlternativeNamesComputedOptional
  }

  // subject_alternative_names_optional - computed: false, optional: true, required: false
  private _subjectAlternativeNamesOptional?: { [key: string]: string } | cdktf.IResolvable | undefined; 
  public get subjectAlternativeNamesOptional() {
    // Getting the computed value is not yet implemented
    return this.interpolationForAttribute('subject_alternative_names_optional') as any;
  }
  public set subjectAlternativeNamesOptional(value: { [key: string]: string } | cdktf.IResolvable | undefined) {
    this._subjectAlternativeNamesOptional = value;
  }
  public resetSubjectAlternativeNamesOptional() {
    this._subjectAlternativeNamesOptional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectAlternativeNamesOptionalInput() {
    return this._subjectAlternativeNamesOptional
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      subject_alternative_names_computed_optional: cdktf.hashMapper(cdktf.anyToTerraform)(this._subjectAlternativeNamesComputedOptional),
      subject_alternative_names_optional: cdktf.hashMapper(cdktf.anyToTerraform)(this._subjectAlternativeNamesOptional),
    };
  }
}
"
`;
