// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`granular-imports nested sub-structs snapshot typescript 1`] = `
"import { Construct } from "constructs";
import { Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running \`cdktf get\`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { Deployment } from "./.gen/providers/kubernetes/deployment";
import { KubernetesProvider } from "./.gen/providers/kubernetes/provider";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    new KubernetesProvider(this, "kubernetes", {});
    new Deployment(this, "example", {
      metadata: {
        labels: {
          test: "MyExampleApp",
        },
        name: "terraform-example",
      },
      spec: {
        replicas: Token.asString(3),
        selector: {
          matchLabels: {
            test: "MyExampleApp",
          },
        },
        template: {
          metadata: {
            labels: {
              test: "MyExampleApp",
            },
          },
          spec: {
            container: [
              {
                image: "nginx:1.21.6",
                livenessProbe: {
                  httpGet: {
                    httpHeader: [
                      {
                        name: "X-Custom-Header",
                        value: "Awesome",
                      },
                    ],
                    path: "/",
                    port: Token.asString(80),
                  },
                  initialDelaySeconds: 3,
                  periodSeconds: 3,
                },
                name: "example",
                resources: {
                  limits: {
                    cpu: "0.5",
                    memory: "512Mi",
                  },
                  requests: {
                    cpu: "250m",
                    memory: "50Mi",
                  },
                },
              },
            ],
          },
        },
      },
    });
  }
}
"
`;

exports[`granular-imports should handle most cdktf and provider constructs for granular imports snapshot typescript 1`] = `
"import { Construct } from "constructs";
import {
  VariableType,
  TerraformVariable,
  TerraformOutput,
  Token,
  TerraformCount,
  Op,
  RemoteBackend,
  TerraformStack,
} from "cdktf";
/*
 * Provider bindings are generated by running \`cdktf get\`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { ComputeAutoscaler } from "./.gen/providers/google/compute-autoscaler";
import { ComputeInstanceGroupManager } from "./.gen/providers/google/compute-instance-group-manager";
import { GoogleProvider } from "./.gen/providers/google/provider";
import { DataLocalFile } from "./.gen/providers/local/data-local-file";
import { LocalProvider } from "./.gen/providers/local/provider";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    new RemoteBackend(this, {
      organization: "example_corp",
      workspaces: [
        {
          name: "my-app-prod",
        },
      ],
    });
    /*Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
    You can read more about this at https://cdk.tf/variables*/
    new GoogleProvider(this, "google", {
      project: "my-project",
      region: "us-central1",
    });
    new LocalProvider(this, "local", {});
    const imageId = new TerraformVariable(this, "image_id", {
      type: VariableType.STRING,
    });
    const cdktfTerraformOutputImageId = new TerraformOutput(
      this,
      "image_id_3",
      {
        value: imageId.value,
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    cdktfTerraformOutputImageId.overrideLogicalId("image_id");
    /*In most cases loops should be handled in the programming language context and 
    not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
    you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
    you need to keep this like it is.*/
    const exampleCount = TerraformCount.of(Token.asNumber("2"));
    new ComputeAutoscaler(this, "example", {
      autoscalingPolicy: {
        cooldownPeriod: 60,
        cpuUtilization: {
          target: 0.5,
        },
        maxReplicas: 8,
        minReplicas: 2,
      },
      name: "example-autoscaler",
      target: "target-for-example-autoscaler",
      zone: "us-east1-b",
      count: exampleCount,
    });
    const defaultVar = new ComputeInstanceGroupManager(this, "default", {
      baseInstanceName: "autoscaler-sample",
      name: "my-igm",
      targetPools: [],
      version: [
        {
          instanceTemplate: Token.asString(1),
          name: "primary",
        },
      ],
      zone: "us-central1-f",
    });
    new DataLocalFile(this, "foo", {
      filename: "./\${" + imageId.value + "}.img",
    });
    const googleComputeAutoscalerDefault = new ComputeAutoscaler(
      this,
      "default_7",
      {
        autoscalingPolicy: {
          cooldownPeriod: 60,
          maxReplicas: Token.asNumber(Op.add(5, 2)),
          minReplicas: 1,
        },
        name: "my-autoscaler",
        target: defaultVar.id,
        zone: "us-central1-f",
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    googleComputeAutoscalerDefault.overrideLogicalId("default");
  }
}
"
`;
