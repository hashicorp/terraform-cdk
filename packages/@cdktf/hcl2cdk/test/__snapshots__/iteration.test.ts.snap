// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`iteration complex for each loops snapshot typescript 1`] = `
"import { Construct } from "constructs";
import { Token, TerraformIterator, Fn, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running \`cdktf get\`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { AcmCertificate } from "./.gen/providers/aws/acm-certificate";
import { AcmCertificateValidation } from "./.gen/providers/aws/acm-certificate-validation";
import { DataAwsRoute53Zone } from "./.gen/providers/aws/data-aws-route53-zone";
import { LbListener } from "./.gen/providers/aws/lb-listener";
import { AwsProvider } from "./.gen/providers/aws/provider";
import { Route53Record } from "./.gen/providers/aws/route53-record";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    new AwsProvider(this, "aws", {
      region: "us-east-1",
    });
    const example = new AcmCertificate(this, "example", {
      domainName: "example.com",
      validationMethod: "DNS",
    });
    const dataAwsRoute53ZoneExample = new DataAwsRoute53Zone(
      this,
      "example_2",
      {
        name: "example.com",
        privateZone: false,
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    dataAwsRoute53ZoneExample.overrideLogicalId("example");
    /*In most cases loops should be handled in the programming language context and
    not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
    you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
    you need to keep this like it is.*/
    const exampleForEachIterator = TerraformIterator.fromList(
      Token.asAny(
        "\${{ for dvo in \${" +
          example.domainValidationOptions +
          "} : dvo.domain_name => {\\n            name   = dvo.resource_record_name\\n            record = dvo.resource_record_value\\n            type   = dvo.resource_record_type\\n          }}}"
      )
    );
    const awsRoute53RecordExample = new Route53Record(this, "example_3", {
      allowOverwrite: true,
      name: Token.asString(
        Fn.lookupNested(exampleForEachIterator.value, ["name"])
      ),
      records: [
        Token.asString(
          Fn.lookupNested(exampleForEachIterator.value, ["record"])
        ),
      ],
      ttl: 60,
      type: Token.asString(
        Fn.lookupNested(exampleForEachIterator.value, ["type"])
      ),
      zoneId: Token.asString(dataAwsRoute53ZoneExample.zoneId),
      forEach: exampleForEachIterator,
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsRoute53RecordExample.overrideLogicalId("example");
    const awsAcmCertificateValidationExample = new AcmCertificateValidation(
      this,
      "example_4",
      {
        certificateArn: example.arn,
        validationRecordFqdns: Token.asList(
          "\${[ for record in \${" +
            awsRoute53RecordExample.fqn +
            "} : record.fqdn]}"
        ),
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsAcmCertificateValidationExample.overrideLogicalId("example");
    const awsLbListenerExample = new LbListener(this, "example_5", {
      certificateArn: Token.asString(
        awsAcmCertificateValidationExample.certificateArn
      ),
      defaultAction: [
        {
          targetGroupArn: "best-target",
          type: "forward",
        },
      ],
      loadBalancerArn: "best-lb-arn",
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsLbListenerExample.overrideLogicalId("example");
  }
}
"
`;

exports[`iteration count loops snapshot typescript 1`] = `
"import { Construct } from "constructs";
import {
  VariableType,
  TerraformVariable,
  Fn,
  Token,
  TerraformCount,
  TerraformStack,
} from "cdktf";
/*
 * Provider bindings are generated by running \`cdktf get\`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { IamUser } from "./.gen/providers/aws/iam-user";
import { AwsProvider } from "./.gen/providers/aws/provider";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    /*Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
    You can read more about this at https://cdk.tf/variables*/
    new AwsProvider(this, "aws", {
      region: "us-east-1",
    });
    const users = new TerraformVariable(this, "users", {
      type: VariableType.set(VariableType.STRING),
    });
    /*In most cases loops should be handled in the programming language context and
    not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
    you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
    you need to keep this like it is.*/
    const lbCount = TerraformCount.of(Token.asNumber(Fn.lengthOf(users.value)));
    new IamUser(this, "lb", {
      name: Token.asString(
        Fn.element(users.value, Token.asNumber(lbCount.index))
      ),
      path: "/system/",
      tags: {
        "tag-key": "tag-value",
      },
      count: lbCount,
    });
  }
}
"
`;

exports[`iteration dynamic blocks snapshot typescript 1`] = `
"import { Construct } from "constructs";
import {
  VariableType,
  TerraformVariable,
  Token,
  TerraformIterator,
  Fn,
  TerraformStack,
} from "cdktf";
/*
 * Provider bindings are generated by running \`cdktf get\`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { ElasticBeanstalkEnvironment } from "./.gen/providers/aws/elastic-beanstalk-environment";
import { AwsProvider } from "./.gen/providers/aws/provider";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    /*Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
    You can read more about this at https://cdk.tf/variables*/
    new AwsProvider(this, "aws", {
      region: "us-east-1",
    });
    const namespace = new TerraformVariable(this, "namespace", {
      type: VariableType.STRING,
    });
    const settings = new TerraformVariable(this, "settings", {
      type: VariableType.list(VariableType.map(VariableType.STRING)),
    });
    /*In most cases loops should be handled in the programming language context and
    not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
    you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
    you need to keep this like it is.*/
    const tfenvtestDynamicIterator0 = TerraformIterator.fromList(
      Token.asAny(settings.value)
    );
    new ElasticBeanstalkEnvironment(this, "tfenvtest", {
      application: "best-app",
      name: "tf-test-name",
      solutionStackName: "64bit Amazon Linux 2018.03 v2.11.4 running Go 1.12.6",
      setting: tfenvtestDynamicIterator0.dynamic({
        name: Fn.lookupNested(tfenvtestDynamicIterator0.value, ['["name"]']),
        namespace: namespace.value,
        value: Fn.lookupNested(tfenvtestDynamicIterator0.value, ['["value"]']),
      }),
    });
  }
}
"
`;

exports[`iteration ensure availability zone is not ignored snapshot typescript 1`] = `
"import { Construct } from "constructs";
import {
  VariableType,
  TerraformVariable,
  TerraformCount,
  Fn,
  Token,
  TerraformStack,
} from "cdktf";
/*
 * Provider bindings are generated by running \`cdktf get\`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { DataAwsAvailabilityZones } from "./.gen/providers/aws/data-aws-availability-zones";
import { AwsProvider } from "./.gen/providers/aws/provider";
import { Subnet } from "./.gen/providers/aws/subnet";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    /*Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
    You can read more about this at https://cdk.tf/variables*/
    new AwsProvider(this, "aws", {
      region: "us-east-1",
    });
    const publicSubnetCount = new TerraformVariable(
      this,
      "public_subnet_count",
      {
        default: 2,
        description: "Number of public subnets to create",
        type: VariableType.NUMBER,
      }
    );
    const available = new DataAwsAvailabilityZones(this, "available", {
      state: "available",
    });
    /*In most cases loops should be handled in the programming language context and
    not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
    you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
    you need to keep this like it is.*/
    const publicCount = TerraformCount.of(publicSubnetCount.numberValue);
    new Subnet(this, "public", {
      availabilityZone: Token.asString(
        Fn.lookupNested(available.names, [publicCount.index])
      ),
      cidrBlock: "10.0.1.0/24",
      vpcId: "10123",
      count: publicCount,
    });
  }
}
"
`;

exports[`iteration for each on list using splat snapshot typescript 1`] = `
"import { Construct } from "constructs";
import {
  VariableType,
  TerraformVariable,
  Fn,
  Token,
  TerraformIterator,
  TerraformStack,
} from "cdktf";
/*
 * Provider bindings are generated by running \`cdktf get\`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { KmsKey } from "./.gen/providers/aws/kms-key";
import { AwsProvider } from "./.gen/providers/aws/provider";
import { S3Bucket } from "./.gen/providers/aws/s3-bucket";
import { S3BucketObject } from "./.gen/providers/aws/s3-bucket-object";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    /*Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
    You can read more about this at https://cdk.tf/variables*/
    new AwsProvider(this, "aws", {
      region: "us-east-1",
    });
    const buckets = new TerraformVariable(this, "buckets", {
      type: VariableType.list(VariableType.STRING),
    });
    const examplekms = new KmsKey(this, "examplekms", {
      deletionWindowInDays: 7,
      description: "KMS key 1",
    });
    /*In most cases loops should be handled in the programming language context and
    not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
    you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
    you need to keep this like it is.*/
    const examplebucketForEachIterator = TerraformIterator.fromList(
      Token.asAny(Fn.toset(Fn.lookupNested(buckets.value, ["*"])))
    );
    const examplebucket = new S3Bucket(this, "examplebucket", {
      acl: "private",
      bucket: Token.asString(examplebucketForEachIterator.key),
      forEach: examplebucketForEachIterator,
    });
    /*In most cases loops should be handled in the programming language context and
    not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
    you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
    you need to keep this like it is.*/
    const examplebucketObjectForEachIterator = TerraformIterator.fromList(
      Token.asAny(Fn.toset(Fn.lookupNested(examplebucket, ["*"])))
    );
    new S3BucketObject(this, "examplebucket_object", {
      bucket: examplebucketObjectForEachIterator.key,
      key: "someobject",
      kmsKeyId: examplekms.arn,
      source: "index.html",
      forEach: examplebucketObjectForEachIterator,
    });
  }
}
"
`;

exports[`iteration for_each loops snapshot typescript 1`] = `
"import { Construct } from "constructs";
import {
  VariableType,
  TerraformVariable,
  Token,
  TerraformIterator,
  TerraformStack,
} from "cdktf";
/*
 * Provider bindings are generated by running \`cdktf get\`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { IamUser } from "./.gen/providers/aws/iam-user";
import { AwsProvider } from "./.gen/providers/aws/provider";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    /*Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
    You can read more about this at https://cdk.tf/variables*/
    new AwsProvider(this, "aws", {
      region: "us-east-1",
    });
    const users = new TerraformVariable(this, "users", {
      type: VariableType.set(VariableType.STRING),
    });
    /*In most cases loops should be handled in the programming language context and
    not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
    you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
    you need to keep this like it is.*/
    const lbForEachIterator = TerraformIterator.fromList(
      Token.asAny(users.value)
    );
    new IamUser(this, "lb", {
      name: Token.asString(lbForEachIterator.key),
      path: "/system/",
      tags: {
        "tag-key": "tag-value",
      },
      forEach: lbForEachIterator,
    });
  }
}
"
`;

exports[`iteration for_each with var usage snapshot typescript 1`] = `
"import { Construct } from "constructs";
import {
  TerraformVariable,
  Fn,
  Token,
  TerraformIterator,
  TerraformStack,
} from "cdktf";
/*
 * Provider bindings are generated by running \`cdktf get\`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { AzureadProvider } from "./.gen/providers/azuread/provider";
import { User } from "./.gen/providers/azuread/user";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    /*Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
    You can read more about this at https://cdk.tf/variables*/
    new AzureadProvider(this, "azuread", {
      tenantId: "00000000-0000-0000-0000-000000000000",
    });
    const azureAdDomainName = new TerraformVariable(
      this,
      "azure_ad_domain_name",
      {
        description: "domain",
      }
    );
    const oneSetOfUsers = new TerraformVariable(this, "one_set_of_users", {
      description: "users",
    });
    const otherSetOfUsers = new TerraformVariable(this, "other_set_of_users", {
      description: "users",
    });
    /*In most cases loops should be handled in the programming language context and
    not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
    you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
    you need to keep this like it is.*/
    const azureUsersForEachIterator = TerraformIterator.fromList(
      Token.asAny(Fn.merge([oneSetOfUsers.value, otherSetOfUsers.value]))
    );
    new User(this, "azure_users", {
      displayName: Token.asString(azureUsersForEachIterator.key),
      userPrincipalName:
        "\${" +
        azureUsersForEachIterator.value +
        "\${" +
        azureAdDomainName.value +
        "}",
      forEach: azureUsersForEachIterator,
    });
  }
}
"
`;

exports[`iteration nested dynamic blocks snapshot typescript 1`] = `
"import { Construct } from "constructs";
import { VariableType, TerraformVariable, Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running \`cdktf get\`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { Application } from "./.gen/providers/azuread/application";
import { AzureadProvider } from "./.gen/providers/azuread/provider";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    /*Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
    You can read more about this at https://cdk.tf/variables*/
    new AzureadProvider(this, "azuread", {
      tenantId: "00000000-0000-0000-0000-000000000000",
    });
    const requiredResourceAccess = new TerraformVariable(
      this,
      "required_resource_access",
      {
        default: [
          {
            resource_access: [
              {
                id: "7ab1d382-f21e-4acd-a863-ba3e13f7da61",
                type: "Role",
              },
            ],
            resource_app_id: "00000003-0000-0000-c000-000000000000",
          },
        ],
        type: VariableType.list(
          VariableType.object({
            resource_access: VariableType.ANY,
            resource_app_id: VariableType.STRING,
          })
        ),
      }
    );
    const bootstrap = new Application(this, "bootstrap", {
      displayName: "test",
      requiredResourceAccess: [],
      groupMembershipClaims: Token.asList("All"),
    });
    /*In most cases loops should be handled in the programming language context and
    not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
    you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
    you need to keep this like it is.*/
    bootstrap.addOverride("dynamic.required_resource_access", {
      for_each: requiredResourceAccess.value,
      content: [
        {
          resource_access: [],
          resource_app_id:
            '\${required_resource_access.value["resource_app_id"]}',
        },
      ],
    });
    /*In most cases loops should be handled in the programming language context and
    not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
    you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
    you need to keep this like it is.*/
    bootstrap.addOverride(
      "dynamic.required_resource_access.0.content.0.dynamic.resource_access",
      {
        for_each: '\${required_resource_access.value["resource_access"]}',
        content: [
          {
            id: '\${resource_access.value["id"]}',
            type: '\${resource_access.value["type"]}',
          },
        ],
      }
    );
  }
}
"
`;

exports[`iteration simple count snapshot typescript 1`] = `
"import { Construct } from "constructs";
import { Token, TerraformCount, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running \`cdktf get\`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { Instance } from "./.gen/providers/aws/instance";
import { AwsProvider } from "./.gen/providers/aws/provider";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    new AwsProvider(this, "aws", {
      region: "us-east-1",
    });
    /*In most cases loops should be handled in the programming language context and
    not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
    you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
    you need to keep this like it is.*/
    const multipleServersCount = TerraformCount.of(Token.asNumber("4"));
    new Instance(this, "multiple_servers", {
      ami: "ami-0c2b8ca1dad447f8a",
      instanceType: "t2.micro",
      tags: {
        Name: "Server \${" + multipleServersCount.index + "}",
      },
      count: multipleServersCount,
    });
  }
}
"
`;
