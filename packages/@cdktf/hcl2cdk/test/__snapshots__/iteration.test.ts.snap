// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`iteration complex for each loops snapshot 1`] = `
"import * as cdktf from \\"cdktf\\";
/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as aws from \\"./.gen/providers/aws\\";
new aws.provider.AwsProvider(this, \\"aws\\", {
  region: \\"us-east-1\\",
});
const awsAcmCertificateExample = new aws.acmCertificate.AcmCertificate(
  this,
  \\"example\\",
  {
    domainName: \\"example.com\\",
    validationMethod: \\"DNS\\",
  }
);
const dataAwsRoute53ZoneExample = new aws.dataAwsRoute53Zone.DataAwsRoute53Zone(
  this,
  \\"example_2\\",
  {
    name: \\"example.com\\",
    privateZone: false,
  }
);
/*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
dataAwsRoute53ZoneExample.overrideLogicalId(\\"example\\");
const awsRoute53RecordExample = new aws.route53Record.Route53Record(
  this,
  \\"example_3\\",
  {
    allowOverwrite: true,
    name: \\"\${each.value.name}\\",
    records: [\\"\${each.value.record}\\"],
    ttl: 60,
    type: \\"\${each.value.type}\\",
    zoneId: cdktf.Token.asString(dataAwsRoute53ZoneExample.zoneId),
  }
);
/*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
awsRoute53RecordExample.overrideLogicalId(\\"example\\");
/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsRoute53RecordExample.addOverride(
  \\"for_each\\",
  \`\\\\\${{
          for dvo in \${awsAcmCertificateExample.domainValidationOptions} : dvo.domain_name => {
            name   = dvo.resource_record_name
            record = dvo.resource_record_value
            type   = dvo.resource_record_type
          }
        }}\`
);
const awsAcmCertificateValidationExample =
  new aws.acmCertificateValidation.AcmCertificateValidation(this, \\"example_4\\", {
    certificateArn: awsAcmCertificateExample.arn,
    validationRecordFqdns: cdktf.Token.asList(
      \`\\\\\${[for record in \${awsRoute53RecordExample.fqn} : record.fqdn]}\`
    ),
  });
/*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
awsAcmCertificateValidationExample.overrideLogicalId(\\"example\\");
const awsLbListenerExample = new aws.lbListener.LbListener(this, \\"example_5\\", {
  certificateArn: cdktf.Token.asString(
    awsAcmCertificateValidationExample.certificateArn
  ),
  defaultAction: [
    {
      target_group_arn: \\"best-target\\",
      type: \\"forward\\",
    },
  ],
  loadBalancerArn: \\"best-lb-arn\\",
});
/*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
awsLbListenerExample.overrideLogicalId(\\"example\\");
"
`;

exports[`iteration count loops snapshot 1`] = `
"import * as cdktf from \\"cdktf\\";
/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as aws from \\"./.gen/providers/aws\\";
/*Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
You can read more about this at https://cdk.tf/variables*/
new aws.provider.AwsProvider(this, \\"aws\\", {
  region: \\"us-east-1\\",
});
const users = new cdktf.TerraformVariable(this, \\"users\\", {});
const awsIamUserLb = new aws.iamUser.IamUser(this, \\"lb\\", {
  name: \`\\\\\${element(\${users.value}, count.index)}\`,
  path: \\"/system/\\",
  tags: {
    \\"tag-key\\": \\"tag-value\\",
  },
});
/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsIamUserLb.addOverride(\\"count\\", \`\\\\\${length(\${users.value})}\`);
"
`;

exports[`iteration dynamic blocks snapshot 1`] = `
"import * as cdktf from \\"cdktf\\";
/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as aws from \\"./.gen/providers/aws\\";
/*Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
You can read more about this at https://cdk.tf/variables*/
new aws.provider.AwsProvider(this, \\"aws\\", {
  region: \\"us-east-1\\",
});
const namespace = new cdktf.TerraformVariable(this, \\"namespace\\", {});
const settings = new cdktf.TerraformVariable(this, \\"settings\\", {});
const awsElasticBeanstalkEnvironmentTfenvtest =
  new aws.elasticBeanstalkEnvironment.ElasticBeanstalkEnvironment(
    this,
    \\"tfenvtest\\",
    {
      application: \\"best-app\\",
      setting: [],
      name: \\"tf-test-name\\",
      solutionStackName: \\"64bit Amazon Linux 2018.03 v2.11.4 running Go 1.12.6\\",
    }
  );
/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsElasticBeanstalkEnvironmentTfenvtest.addOverride(\\"setting\\", {
  for_each: settings.value,
  content: [
    {
      name: '\${setting.value[\\"name\\"]}',
      namespace: namespace.value,
      value: '\${setting.value[\\"value\\"]}',
    },
  ],
});
"
`;

exports[`iteration for each on list using splat snapshot 1`] = `
"import * as cdktf from \\"cdktf\\";
/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as aws from \\"./.gen/providers/aws\\";
/*Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
You can read more about this at https://cdk.tf/variables*/
new aws.provider.AwsProvider(this, \\"aws\\", {
  region: \\"us-east-1\\",
});
const buckets = new cdktf.TerraformVariable(this, \\"buckets\\", {});
const awsKmsKeyExamplekms = new aws.kmsKey.KmsKey(this, \\"examplekms\\", {
  deletionWindowInDays: 7,
  description: \\"KMS key 1\\",
});
const awsS3BucketExamplebucket = new aws.s3Bucket.S3Bucket(
  this,
  \\"examplebucket\\",
  {
    acl: \\"private\\",
    bucket: \\"\${each.key}\\",
  }
);
/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsS3BucketExamplebucket.addOverride(
  \\"for_each\\",
  \`\\\\\${toset(\${buckets.value}.*)}\`
);
const awsS3BucketObjectExamplebucketObject =
  new aws.s3BucketObject.S3BucketObject(this, \\"examplebucket_object\\", {
    bucket: \\"\${each.key}\\",
    key: \\"someobject\\",
    kmsKeyId: awsKmsKeyExamplekms.arn,
    source: \\"index.html\\",
  });
/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsS3BucketObjectExamplebucketObject.addOverride(
  \\"for_each\\",
  \`\\\\\${toset(\${awsS3BucketExamplebucket.fqn}.*)}\`
);
"
`;

exports[`iteration for_each loops snapshot 1`] = `
"import * as cdktf from \\"cdktf\\";
/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as aws from \\"./.gen/providers/aws\\";
/*Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
You can read more about this at https://cdk.tf/variables*/
new aws.provider.AwsProvider(this, \\"aws\\", {
  region: \\"us-east-1\\",
});
const users = new cdktf.TerraformVariable(this, \\"users\\", {});
const awsIamUserLb = new aws.iamUser.IamUser(this, \\"lb\\", {
  name: \\"\${each.key}\\",
  path: \\"/system/\\",
  tags: {
    \\"tag-key\\": \\"tag-value\\",
  },
});
/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsIamUserLb.addOverride(\\"for_each\\", users.value);
"
`;

exports[`iteration for_each with var usage snapshot 1`] = `
"import * as cdktf from \\"cdktf\\";
/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as azuread from \\"./.gen/providers/azuread\\";
/*Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
You can read more about this at https://cdk.tf/variables*/
new azuread.provider.AzureadProvider(this, \\"azuread\\", {
  tenantId: \\"00000000-0000-0000-0000-000000000000\\",
});
const azureAdDomainName = new cdktf.TerraformVariable(
  this,
  \\"azure_ad_domain_name\\",
  {
    description: \\"domain\\",
  }
);
const oneSetOfUsers = new cdktf.TerraformVariable(this, \\"one_set_of_users\\", {
  description: \\"users\\",
});
const otherSetOfUsers = new cdktf.TerraformVariable(
  this,
  \\"other_set_of_users\\",
  {
    description: \\"users\\",
  }
);
const azureadUserAzureUsers = new azuread.user.User(this, \\"azure_users\\", {
  displayName: \\"\${each.key}\\",
  userPrincipalName: \`\\\\\${each.value}\\\\\${\${azureAdDomainName.value}}\`,
});
/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
azureadUserAzureUsers.addOverride(
  \\"for_each\\",
  \`\\\\\${merge(
              \${oneSetOfUsers.value},
              \${otherSetOfUsers.value},
            )}\`
);
"
`;

exports[`iteration simple count snapshot 1`] = `
"/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as aws from \\"./.gen/providers/aws\\";
new aws.provider.AwsProvider(this, \\"aws\\", {
  region: \\"us-east-1\\",
});
const awsInstanceMultipleServers = new aws.instance.Instance(
  this,
  \\"multiple_servers\\",
  {
    ami: \\"ami-0c2b8ca1dad447f8a\\",
    instanceType: \\"t2.micro\\",
    tags: {
      Name: \\"Server \${count.index}\\",
    },
  }
);
/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsInstanceMultipleServers.addOverride(\\"count\\", 4);
"
`;
